# Collections
This chapter looks closer to collections and its best practices.

## Passing collections as a method parameter 

If your method needs to accept a collection as a parameter, then generally `IEnumerable<T>` is the best choice. This offers the most flexibility to the caller. It doesn't matter what concrete collection type they use, and it even allows them to pass lazily evaluated sequences in.

❌ **Bad** We have to call `ToList` before passing argument.
```csharp
void ApplyFilter<T>(this List<T> items, Expression<Func<T, bool>> source)
{
    // ...
}

void Caller() 
{
    var products = dbContext.Products;
    products = products.ToList().ApplyFilter(p => p.Title = "IPhone"); // requires us to add a ToList instead of lazily evaluated IEnumerable
}
```

✅ **Good** Allows the caller to pass in a `lazily evaluated IEnumerable` generated by the LINQ Where.
```csharp
void ApplyFilter<T>(this IEnumerable<T> items, Expression<Func<T, bool>> source)
{
    // ...
}

void Caller() 
{
    var products = dbContext.Products;
    products = products.ApplyFilter(p => p.Title = "IPhone"); // works fine without calling ToList directly
}
```

## Possible multiple enumeration with `IEnumerable<T>`
As `IEnumerable<T>` is not a materialized collection but more cursor on the current element of the enumeration, using multiple functions on `IEnumerable<T>` can lead to possible multiple enumerations.
This becomes a penalty when retrieving the content is expensive as the work is done multiple times, for example it could be an expensive operation that goes to a database multiple time with each enumeration, or it could even return different results in each enumeration.

❌ **Bad** Will enumerate the enumeration twice
```csharp
IEnumerable<int> integers = GetIntegers();
var min = integers.Min();
var max = integers.Max();

Console.Write($"Min: {min} / Max: {max}");

IEnumerable<int> GetIntegers()
{
    Console.WriteLine("Getting integer");
    yield return 1;
    yield return 2;
}
```

Will output:
> Getting integer  
Getting integer  
Min: 1 / Max: 2

✅ **Good** Enumeration get materialized once via `ToList`
```csharp
IEnumerable<int> integers = GetIntegers();
var integerList = integers.ToList();
var min = integerList.Min();
var max = integerList.Max();

Console.Write($"Min: {min} / Max: {max}");

IEnumerable<int> GetIntegers()
{
    Console.WriteLine("Getting integer");
    yield return 1;
    yield return 2;
}
```

Will output:
> Getting integer  
Min: 1 / Max: 2

## Returning null for `IEnumerable<T>`
A lot of **LINQ** operations are built upon the premise that `IEnumerable<T>`, even though it is a reference type, should not be `null` at any given time.

❌ **Bad** Instead of an empty enumeration a `null` will be returned which can confuse a consumer.
```csharp
public IEnumerable<MyDto> GetAll()
{
    if (...)
    {
        return null;
    }
    ...
}
```

✅ **Good** Instead return an empty enumeration.
```csharp
public IEnumerable<MyDto> GetAll()
{
    if (...)
    {
        return Enumerable.Empty<MyDto>();
    }
    ...
}
```