{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tips and tricks","text":"<p>A collection of tips, tricks and smaller pitfalls with smaller code snippets and explanation.</p> <p>Right now there are 88 entries in the collection. The page has multiple sections divided by topic like <code>async</code>/<code>await</code> or <code>Blazor</code> and should give a good overview over common scenarios.</p> <p>Go ahead to the official page here: tips and tricks.</p>"},{"location":"#support-contributing","title":"Support &amp; Contributing","text":"<p>It helps out if you give this repository a \u2b50.</p> <p>Feel free to contribute samples via Pull Request.</p> <p>Thanks to all contributors:</p> <p> </p>"},{"location":"#contact","title":"Contact","text":"<p>If you have any questions, let me know. You can reach me here:</p> <p> </p>"},{"location":"array/","title":"Array","text":"<p>This page will look into arrays and their usage.</p>"},{"location":"array/#prefer-jagged-arrays-over-multidimensional","title":"Prefer jagged arrays over multidimensional","text":"<p>In a multidimensional array, each element in each dimension has the same, fixed size as the other elements in that dimension. In a jagged array, which is an array of arrays, each inner array can be of a different size. By only using the space that\u2019s needed for a given array, no space is wasted. Also from a performance point of view a jagged array performs generally better than a multidimensional array.</p> <p>\u274c Bad Multidimensional array performs less optimal and can waste space.  <pre><code>int[,] multiDimArray = { {1, 2}, {3, 4}};\n</code></pre></p> <p>\u2705 Good Jagged array performs generally better and only uses the really needed space. <pre><code>int[][] jaggedArray = { new int[] {1, 2}, new int [] {3, 4}};\n</code></pre></p>"},{"location":"array/#benchmark","title":"Benchmark","text":"<pre><code>[MemoryDiagnoser]\npublic class Arrays\n{\n[Params(25, 100)]\npublic int Size { get; set; }\n\n[Benchmark]\npublic int[][] CreateAndFillJaggedArray()\n{\nint[][] jaggedArray = new int[Size][];\nfor (var i = 0; i &lt; Size; i++)\n{\njaggedArray[i] = new int[Size];\nfor (var j = 0; j &lt; Size; j++) jaggedArray[i][j] = i + j;\n}\n\nreturn jaggedArray;\n}\n\n[Benchmark]\npublic int[,] CreateAndFillMultidimensionalArray()\n{\nint[,] multidimArray = new int[Size, Size];\nfor (var i = 0; i &lt; Size; i++)\n{\nfor (var j = 0; j &lt; Size; j++) multidimArray[i, j] = i + j;\n}\n\nreturn multidimArray;\n}\n}\n</code></pre> <p>Result: <pre><code>|                             Method | Size |        Mean |     Error |    StdDev |      Median |   Gen 0 |  Gen 1 | Allocated |\n|----------------------------------- |----- |------------:|----------:|----------:|------------:|--------:|-------:|----------:|\n|           CreateAndFillJaggedArray |   25 |    717.7 ns |  15.51 ns |  43.50 ns |    700.3 ns |  0.8183 |      - |   3.34 KB |\n| CreateAndFillMultidimensionalArray |   25 |  1,480.2 ns |  29.49 ns |  82.21 ns |  1,463.7 ns |  0.6065 |      - |   2.48 KB |\n|           CreateAndFillJaggedArray |  100 |  9,895.6 ns | 143.22 ns | 126.96 ns |  9,900.8 ns | 10.3302 | 0.0153 |  42.21 KB |\n| CreateAndFillMultidimensionalArray |  100 | 16,374.7 ns | 319.00 ns | 567.02 ns | 16,311.2 ns |  9.5215 | 0.0305 |   39.1 KB |\n</code></pre></p>"},{"location":"array/#locality-matters","title":"Locality matters","text":"<p>Memory location matters. Accessing memory location sequentially as opposed to \u201cjumping\u201d around to read some memory address.</p> <p>\u274c Bad Do not access memory sequentially. <pre><code>public int NotLocal()\n{\nvar sum = 0;\nfor (var i = 0; i &lt; _table.GetLength(1); i++)\n{\nfor (var j = 0; j &lt; _table.GetLength(0); j++) sum += _table[j, i];\n}\n\nreturn sum;\n}\n</code></pre></p> <p>\u2705 Good Accessing memory sequentially. <pre><code>public int Local()\n{\nvar sum = 0;\nfor (var i = 0; i &lt; _table.GetLength(0); i++)\n{\nfor (var j = 0; j &lt; _table.GetLength(1); j++) sum += _table[i, j];\n}\n\nreturn sum;\n}\n</code></pre></p>"},{"location":"array/#benchmark_1","title":"Benchmark","text":"<p>Results for the given example above: <pre><code>|   Method |     Mean |   Error |  StdDev | Ratio | RatioSD |\n|--------- |---------:|--------:|--------:|------:|--------:|\n|    Local | 120.8 us | 2.35 us | 2.70 us |  1.00 |    0.00 |\n| NotLocal | 158.6 us | 3.09 us | 3.56 us |  1.31 |    0.05 |\n</code></pre></p>"},{"location":"async_await/","title":"async await","text":"<p>The following chapter will deep dive into tips, tricks and pitfalls when it comes down to <code>async</code> and <code>await</code> in C#.</p>"},{"location":"async_await/#elide-await-keyword-exceptions","title":"Elide await keyword - Exceptions","text":"<p>Eliding the await keyword can lead to a less traceable stacktrace due to the fact that every <code>Task</code> which doesn\u2019t get awaited, will not be part of the stack trace.</p> <p>\u274c Bad <pre><code>using System;\nusing System.Threading.Tasks;\n\ntry\n{\nawait DoWorkWithoutAwaitAsync();\n}\ncatch (Exception e)\n{\nConsole.WriteLine(e);\n}\n\nstatic Task DoWorkWithoutAwaitAsync()\n{\nreturn ThrowExceptionAsync();\n}\n\nstatic async Task ThrowExceptionAsync()\n{\nawait Task.Yield();\nthrow new Exception(\"Hey\");\n}\n</code></pre></p> <p>Will result in</p> <pre><code>System.Exception: Hey  \n at Program.&lt;&lt;Main&gt;$&gt;g__ThrowExceptionAsync|0_1()  \n at Program.&lt;Main&gt;$(String[] args)  \n</code></pre> <p>\u2705 Good If speed and allocation is not very crucial, add the <code>await</code> keyword. <pre><code>using System;\nusing System.Threading.Tasks;\n\ntry\n{\nawait DoWorkWithoutAwaitAsync();\n}\ncatch (Exception e)\n{\nConsole.WriteLine(e);\n}\n\nstatic async Task DoWorkWithoutAwaitAsync()\n{\nawait ThrowExceptionAsync();\n}\n\nstatic async Task ThrowExceptionAsync()\n{\nawait Task.Yield();\nthrow new Exception(\"Hey\");\n}\n</code></pre></p> <p>Will result in: <pre><code>System.Exception: Hey\n   at Program.&lt;&lt;Main&gt;$&gt;g__ThrowExceptionAsync|0_1()\n   at Program.&lt;&lt;Main&gt;$&gt;g__DoWorkWithoutAwaitAsync|0_0()\n   at Program.&lt;Main&gt;$(String[] args)\n</code></pre></p> <p>\ud83d\udca1 Info: Eliding the <code>async</code> keyword will also elide the whole state machine. In very hot paths that might be worth a consideration. In normal cases one should not elide the keyword. The allocations one is saving is depending on the circumstances but a normally very very small especially if only smaller objects are passed around. Also performance-wise there is no big gain when eliding the keyword (we are talking nano seconds). Please measure first and act afterwards.</p>"},{"location":"async_await/#elide-await-keyword-using-block","title":"Elide await keyword - using block","text":"<p>Eliding inside an <code>using</code> block can lead to a disposed object before the <code>Task</code> is finished.</p> <p>\u274c Bad Here the download will be aborted / the <code>HttpClient</code> gets disposed: <pre><code>public Task&lt;string&gt; GetContentFromUrlAsync(string url)\n{\nusing var client = new HttpClient();\nreturn client.GetStringAsync(url);\n}\n</code></pre></p> <p>\u2705 Good <pre><code>public async Task&lt;string&gt; GetContentFromUrlAsync(string url)\n{\nusing var client = new HttpClient();\nreturn await client.GetStringAsync(url);\n}\n</code></pre></p> <p>\ud83d\udca1 Info: Eliding the <code>async</code> keyword will also elide the whole state machine. In very hot paths that might be worth a consideration. In normal cases one should not elide the keyword. The allocations one is saving is depending on the circumstances but a normally very very small especially if only smaller objects are passed around. Also performance-wise there is no big gain when eliding the keyword (we are talking nano seconds). Please measure first and act afterwards.</p>"},{"location":"async_await/#return-null-task-or-taskt","title":"Return <code>null</code> <code>Task</code> or <code>Task&lt;T&gt;</code>","text":"<p>When returning directly <code>null</code> from a synchronous call (no <code>async</code> or <code>await</code>) will lead to <code>NullReferenceException</code>:</p> <p>\u274c Bad Will throw <code>NullReferenceException</code> <pre><code>await GetAsync();\n\nstatic Task&lt;string&gt; GetAsync()\n{\nreturn null;\n}\n</code></pre></p> <p>\u2705 Good Use <code>Task.FromResult</code>:</p> <pre><code>await GetAsync();\n\nstatic Task&lt;string&gt; GetAsync()\n{\nreturn Task.FromResult(null);\n}\n</code></pre>"},{"location":"async_await/#async-void","title":"<code>async void</code>","text":"<p>The problem with <code>async void</code> is first they are not awaitable and second they suffer the same problem with exceptions and stack trace as discussed a bit earlier. It is basically fire and forget.</p> <p>\u274c Bad Not awaited <pre><code>public async void DoAsync()\n{\nawait SomeAsyncOp();\n}\n</code></pre></p> <p>\u2705 Good return <code>Task</code> instead of <code>void</code> <pre><code>public async Task DoAsync()\n{\nawait SomeAsyncOp();\n}\n</code></pre></p> <p>\ud83d\udca1 Info: There are valid cases for <code>async void</code> like top level event handlers.</p>"},{"location":"async_await/#listtforeach-with-async","title":"<code>List&lt;T&gt;.ForEach</code> with <code>async</code>","text":"<p><code>List&lt;T&gt;.ForEach</code> and in general a lot of LINQ methods don\u2019t go well with <code>async</code> <code>await</code>:</p> <p>\u274c Bad Is the same as <code>async void</code> <pre><code>var ids = new List&lt;int&gt;();\n// ...\nids.ForEach(id =&gt; _myRepo.UpdateAsync(id));\n</code></pre></p> <p>One could thing adding <code>async</code> into the lamdba would do the trick:</p> <p>\u274c Bad Still the same as <code>async void</code> because <code>List&lt;T&gt;.ForEach</code> takes an <code>Action</code> and not a <code>Func&lt;Task&gt;</code>. <pre><code>var ids = new List&lt;int&gt;();\n// ...\nids.ForEach(async id =&gt; await _myRepo.UpdateAsync(id));\n</code></pre></p> <p>\u2705 Good Enumerate through the list via <code>foreach</code> <pre><code>foreach (var id in ids)\n{\nawait _myRepo.UpdateAsync(id);\n}\n</code></pre></p>"},{"location":"async_await/#favor-await-over-synchronous-calls","title":"Favor <code>await</code> over synchronous calls","text":"<p>Using blocking calls instead of <code>await</code> can lead to potential deadlocks and other side effects like a poor stack trace in case of an exception and less scalability in web frameworks like ASP.NET core.</p> <p>\u274c Bad This call blocks the thread. <pre><code>public async Task SomeOperationAsync()\n{\nawait ...\n}\n\npublic void Do()\n{\nSomeOperationAsync().Wait();\n}\n</code></pre></p> <p>\u2705 Good Use <code>async</code> &amp; <code>await</code> in the whole chain <pre><code>public async Task SomeOperationAsync()\n{\nawait ...\n}\n\npublic async Task Do()\n{\nawait SomeOperationAsync();\n}\n</code></pre></p>"},{"location":"async_await/#favor-getawaitergetresult-over-wait-and-result","title":"Favor <code>GetAwaiter().GetResult()</code> over <code>Wait</code> and <code>Result</code>","text":"<p><code>Task.GetAwaiter().GetResult()</code> is preferred over <code>Task.Wait</code> and <code>Task.Result</code> because it propagates exceptions rather than wrapping them in an AggregateException. </p> <p>\u274c Bad <pre><code>string content = DownloadAsync().Result;\n</code></pre></p> <p>\u2705 Good <pre><code>string content = DownloadAsync().GetAwaiter().GetResult();\n</code></pre></p>"},{"location":"async_await/#dont-use-taskdelay-for-small-precise-waiting-times","title":"Don\u2019t use <code>Task.Delay</code> for small precise waiting times","text":"<p><code>Task.Delay</code>\u2018s internal timer is dependent on the underlying OS. On most windows machines this resolution is about 15ms.</p> <p>So: <code>Task.Delay(1)</code> will not wait one millisecond but something between one and 15 milliseconds.</p> <pre><code>var stopwatch = Stopwatch.StartNew();\nawait Task.Delay(1);\nstopwatch.Stop(); // Don't account the Console.WriteLine into the timer\nConsole.WriteLine($\"Delay was {stopwatch.ElapsedMilliseconds} ms\");\n</code></pre> <p>Will print for example:</p> <p>Delay was 6 ms</p>"},{"location":"async_await/#properly-awaiting-concurrent-tasks","title":"Properly awaiting concurrent tasks","text":"<p>Often times tasks are independent of each other and can be awaited independently.</p> <p>\u274c Bad The following code will run roughly 1 second. <pre><code>await DoOperationAsync();\nawait DoOperationAsync();\n\nasync Task DoOperationAsync()\n{\nawait Task.Delay(500);\n} </code></pre></p> <p>\u2705 Good When tasks or their data is independent they can be awaited independently for maximum benefits. The following code will run roughly 0.5 seconds.</p> <pre><code>var t1 = DoOperationAsync();\nvar t2 = DoOperationAsync();\nawait t1;\nawait t2;\n\nasync Task DoOperationAsync()\n{\nawait Task.Delay(500);\n} </code></pre> <p>An alternative to this would be <code>Task.WhenAll</code>: <pre><code>var t1 = DoOperationAsync();\nvar t2 = DoOperationAsync();\nawait Task.WhenAll(t1, t2); // Can also be inlined\n\nasync Task DoOperationAsync()\n{\nawait Task.Delay(500);\n} </code></pre></p>"},{"location":"async_await/#configureawait-with-await-using-statement","title":"<code>ConfigureAwait</code> with <code>await using</code> statement","text":"<p>Since C# 8 you can provide an <code>IAsyncDisposable</code> which allows to have asynchrnous code in the <code>Dispose</code> method. Also this allows to call the following construct:</p> <pre><code>await using var dbContext = await dbContextFactory.CreateDbContextAsync().ConfigureAwait(false);\n</code></pre> <p>In this example <code>CreateDbContextAsync</code> uses the <code>ConfigureAwait(false)</code> but not the <code>IAsyncDisposable</code>. To make that work we have to break apart the statment like this:</p> <pre><code>var dbContext = await dbContextFactory.CreateDbContextAsync().ConfigureAwait(false);\nawait using (dbContext.ConfigureAwait(false))\n{\n// ...\n}\n</code></pre> <p>The last part has the \u201cugly\u201d snippet that you have to introduce a new \u201cblock\u201d for the <code>using</code> statement. For that there is a easy workaround: <pre><code>var blogDbContext = await dbContextFactory.CreateDbContextAsync().ConfigureAwait(false);\nawait using var _ = blogDbContext.ConfigureAwait(false);\n// You don't need the {} block here\n</code></pre></p>"},{"location":"async_await/#avoid-async-in-constructors","title":"Avoid Async in Constructors","text":"<p>Constructors are meant to initialize objects synchronously, as their primary purpose is to set up the initial state of the object. When you need to perform asynchronous operations during object initialization, using async methods in constructors can lead to issues such as deadlocks or incorrect object initialization. Instead, use a static asynchronous factory method or a separate asynchronous initialization method to ensure safe and proper object initialization.</p> <p>Using async operations in constructors can be problematic for several reasons like Deadlocks, Incomplete Initialization, and Exception Handling.</p> <p>\u274c Bad Calling async methods in constructors</p> <pre><code>public class MyClass\n{\npublic MyClass()\n{\nInitializeAsync().GetAwaiter().GetResult();\n}\n\nprivate async Task InitializeAsync() =&gt; await LoadDataAsync();\n</code></pre> <p>\u2705 Good: Option 1 - Static asynchronous factory method:</p> <pre><code>public class MyClass\n{\nprivate MyClass() { }\n\npublic static async Task&lt;MyClass&gt; CreateAsync()\n{\nvar instance = new MyClass();\nawait instance.InitializeAsync();\nreturn instance;\n}\n\nprivate async Task InitializeAsync() =&gt; await LoadDataAsync();\n</code></pre> <p>\u2705 Good: Option 2 - Separate asynchronous initialization method:</p> <pre><code>public class MyClass\n{\npublic async Task InitializeAsync() =&gt; await LoadDataAsync();\n</code></pre>"},{"location":"blazor/","title":"Blazor","text":"<p>The following chapter show some tips and tricks in regards to Blazor.</p>"},{"location":"blazor/#cascadingvalue-fixed","title":"<code>CascadingValue</code> fixed","text":"<p>CascadingValues are used, as the name implies, the cascade a parameter down the hierarchy. The problem with that is, that every child component will listen to changes to the original value. This can get expensive. If your component does not rely on updates, you can pin / fix this value. For that you can use the IsFixed parameter.</p> <p>\u274c Bad in case <code>SomeOtherComponents</code> does not need update of the cascading value <pre><code>&lt;CascadingValue Value=\"this\"&gt;\n    &lt;SomeOtherComponents&gt;\n&lt;/CascadingValue&gt;\n</code></pre></p> <p>\u2705 Good If the component does not need further updates (or the value never changes anyway) we can fix the value. <pre><code>&lt;CascadingValue Value=\"this\" IsFixed=\"true\"&gt;\n    &lt;SomeOtherComponents&gt;\n&lt;/CascadingValue&gt;\n</code></pre></p>"},{"location":"blazor/#key-directive","title":"<code>@key</code> directive","text":"<p>Blazor diff engine determines which elements have to be re-rendered on every render cycle. It does that via sequence numbers. That works in most of cases very well, but adding or removing items in the middle or at the beginning of the list, will lead to re-rendering the whole list instead of the single entry. </p> <p>\u274c Bad in case we entries are added in the middle or at the beginning. <pre><code>&lt;ul&gt;\n    @foreach (var item in items)\n    {\n        &lt;li&gt;@item&lt;/li&gt;\n    }\n&lt;/ul&gt;\n</code></pre></p> <p>\u2705 Good Helping Blazor how it should find the difference between two render cycles. <pre><code>&lt;ul&gt;\n    @foreach (var item in items)\n    {\n        @* With the @key attribute we define what makes the element unique\n           Based on this Blazor can determine whether or not it has to re-render\n           the element\n        *@\n        &lt;li @key=\"item\"&gt;@item&lt;/li&gt;\n    }\n&lt;/ul&gt;\n</code></pre></p> <p>\ud83d\udca1 Info: If you want to know more about <code>@key</code> here is article about that topic.</p>"},{"location":"blazor/#statehaschanged-from-async-call-without-invokeasync","title":"<code>StateHasChanged</code> from async call without <code>InvokeAsync</code>","text":"<p>In the current state (.net6 / .net7.0 preview 4) Blazor WASM only runs on one thread at the time. Therefore switching context via <code>await</code> will still be run on the main UI thread. Once Blazor WASM introduces real threads, code which invokes UI changes from a background thread will throw an exception. For Blazor Server this holds true today, even though the <code>SynchronizationContext</code> tries to be as much as possible single threaded.</p> <p>\u274c Bad Can lead to exceptions on Blazor Server now or Blazor WASM in the future. <pre><code>protected override void OnInitialized()\n{\nbase.OnInitialized();\nTimer = new System.Threading.Timer(_ =&gt;\n{\nStateHasChanged();\n}, null, 500, 500);\n}\n</code></pre></p> <p>\u2705 Good Call <code>InvokeAsync</code> to force rendering on the main UI thread. <pre><code>protected override void OnInitialized()\n{\nbase.OnInitialized();\nTimer = new System.Threading.Timer(_ =&gt;\n{\nInvokeAsync(StateHasChanged);\n}, null, 500, 500);\n}\n</code></pre></p>"},{"location":"blazor/#use-jsimport-or-jsexport-attributes-to-simplify-the-interop","title":"Use <code>JSImport</code> or <code>JSExport</code> attributes to simplify the interop","text":"<p>With .NET 7 developers can use <code>JSImportAttribute</code> to automatically import a javascript function into dotnet and use it as regular C# function. Also the opposite is possible. This only works on client-side Blazor (also called Blazor WASM).</p> <pre><code>// We have to mark our class partial otherwise SourceCodeGenerator can't add code\npublic partial class MyComponent\n{\n// Super easy way to import a Javascript function to .NET\n[JSImport(\"console.log\")]\nstatic partial void Log(string message);\n\n// We can also export functions, so that we can use them in JavaScript\n// Dotnet will take care of marshalling\n[JSExport]\n[return: JSMarshalAs&lt;JSType.Date&gt;]\npublic static DateTime Now()\n{\nreturn DateTime.Now;\n}\n\n// The imported functions can be called like every other .NET function\n</code></pre>"},{"location":"blazor/#cancelling-a-navigation","title":"Cancelling a navigation","text":"<p>Since .net 7 it is possible to intercept a navigation request, which either goes to an internal or external page. For that we can utilize the <code>NavigationLock</code> component. It distinguishes between internal and external calls. External calls are always handled via a JS popup. The same can be used for internal calls as well.</p> <pre><code>@inject IJSRuntime JSRuntime\n\n&lt;NavigationLock OnBeforeInternalNavigation=\"OnBeforeInternalNavigation\" ConfirmExternalNavigation=\"true\" /&gt;\n\n@code {\nprivate async Task OnBeforeInternalNavigation(LocationChangingContext context)\n{\n// This just displays the built-in browser confirm dialog, but you can display a custom prompt\n// for internal navigations if you want.\nvar isConfirmed = await JSRuntime.InvokeAsync&lt;bool&gt;(\"confirm\", \"Are you sure you want to continue?\");\n\nif (!isConfirmed)\n{\ncontext.PreventNavigation();\n}\n}\n}\n</code></pre>"},{"location":"collections/","title":"Collections","text":"<p>This chapter looks closer to collections and its best practices.</p>"},{"location":"collections/#passing-collections-as-a-method-parameter","title":"Passing collections as a method parameter","text":"<p>If your method needs to accept a collection as a parameter, then generally <code>IEnumerable&lt;T&gt;</code> is ok and this offers the most flexibility to the caller. It doesn\u2019t matter what concrete collection type they use, and it even allows them to pass lazily evaluated sequences in, This is a <code>general</code> approach and for preventing multiple enumeration we can call <code>ToList()</code> in first of executing method or we can use <code>IReadOnlyCollection&lt;T&gt;</code> or <code>IReadOnlyList</code> for preventing multiple enumeration.</p> <p>\u274c Bad using <code>IEnumerable&lt;T&gt;</code> generally as input collection type is ok, but without using <code>ToList()</code> in first of executing could create multiple enumeration. <pre><code>void PrintProducts(IEnumerable&lt;Product&gt; products)\n{\n// First Enumeration.\nConsole.WriteLine($\"Product Count is: {products.Count()}.\");\n\n// Second Enumeration.\nforeach(var product in products)\n{\nConsole.WriteLine($\"Id: {product.Id} - Title: {product.Title}\");\n}\n}\n\nvoid Caller() {\nPrintProducts(products.Where(p =&gt; p.Title == \"IPhone\")); }\n</code></pre></p> <p>\u2705 Good With using <code>IReadOnlyCollection&lt;T&gt;</code> in our parameter specifically, we can prevent unexpected behaviors and multiple enumerations. <pre><code>void PrintProducts(IReadOnlyCollection&lt;Product&gt; products)\n{\nConsole.WriteLine($\"Product Count is: {products.Count}.\");\n\nforeach(var product in products)\n{\nConsole.WriteLine($\"Id: {product.Id} - Title: {product.Title}\");\n}\n}\n\nvoid Caller() {\nPrintProducts(products.where(p =&gt; p.Title == \"IPhone\").AsReadOnly()); }\n</code></pre></p> <p>\u2705 Good With using <code>IEnumerable&lt;T&gt;</code> in our parameter specifically and calling <code>ToList()</code> in first line of executing, we can prevent unexpected behaviors and multiple enumerations. <pre><code>void PrintProducts(IEnumerable&lt;Product&gt; products)\n{\nvar items = products.ToList();\n\nConsole.WriteLine($\"Product Count is: {items.Count}.\");\n\nforeach(var product in items)\n{\nConsole.WriteLine($\"Id: {product.Id} - Title: {product.Title}\");\n}\n}\n\nvoid Caller() {\nPrintProducts(products.Where(p =&gt; p.Title == \"IPhone\")); }\n</code></pre></p>"},{"location":"collections/#possible-multiple-enumeration-with-ienumerablet","title":"Possible multiple enumeration with <code>IEnumerable&lt;T&gt;</code>","text":"<p>As <code>IEnumerable&lt;T&gt;</code> is not a materialized collection but more cursor on the current element of the enumeration, using multiple functions on <code>IEnumerable&lt;T&gt;</code> can lead to possible multiple enumerations. This becomes a penalty when retrieving the content is expensive as the work is done multiple times, for example it could be an expensive operation that goes to a database multiple time with each enumeration, or it could even return different results in each enumeration.</p> <p>\u274c Bad Will enumerate the enumeration twice <pre><code>IEnumerable&lt;int&gt; integers = GetIntegers();\nvar min = integers.Min();\nvar max = integers.Max();\n\nConsole.Write($\"Min: {min} / Max: {max}\");\n\nIEnumerable&lt;int&gt; GetIntegers()\n{\nConsole.WriteLine(\"Getting integer\");\nyield return 1;\nyield return 2;\n}\n</code></pre></p> <p>Will output:</p> <p>Getting integer Getting integer Min: 1 / Max: 2</p> <p>\u2705 Good Enumeration get materialized once via <code>ToList</code> <pre><code>IEnumerable&lt;int&gt; integers = GetIntegers();\nvar integerList = integers.ToList();\nvar min = integerList.Min();\nvar max = integerList.Max();\n\nConsole.Write($\"Min: {min} / Max: {max}\");\n\nIEnumerable&lt;int&gt; GetIntegers()\n{\nConsole.WriteLine(\"Getting integer\");\nyield return 1;\nyield return 2;\n}\n</code></pre></p> <p>Will output:</p> <p>Getting integer Min: 1 / Max: 2</p>"},{"location":"collections/#returning-null-for-ienumerablet","title":"Returning null for <code>IEnumerable&lt;T&gt;</code>","text":"<p>A lot of LINQ operations are built upon the premise that <code>IEnumerable&lt;T&gt;</code>, even though it is a reference type, should not be <code>null</code> at any given time.</p> <p>\u274c Bad Instead of an empty enumeration a <code>null</code> will be returned which can confuse a consumer. <pre><code>public IEnumerable&lt;MyDto&gt; GetAll()\n{\nif (...)\n{\nreturn null;\n}\n...\n}\n</code></pre></p> <p>\u2705 Good Instead return an empty enumeration. <pre><code>public IEnumerable&lt;MyDto&gt; GetAll()\n{\nif (...)\n{\nreturn Enumerable.Empty&lt;MyDto&gt;();\n}\n...\n}\n</code></pre></p>"},{"location":"collections/#consider-ireadonlycollectiont-if-you-always-return-an-in-memory-list","title":"Consider <code>IReadOnlyCollection&lt;T&gt;</code> if you always return an in memory list","text":"<p>Many developers assume that <code>IEnumerable</code> is the best type to return a collection from a method. It\u2019s not a bad choice, but it does mean that the caller cannot make any assumptions about the collection they have been given, If enumerating the return value will be an in-memory operation or a potentially expensive action. They also don\u2019t know if they can safely enumerate it more than once. So often the caller ends up doing a <code>.ToList()</code> or similar on the collection you passed, which is wasteful if it was already a <code>List&lt;T&gt;</code> already. This is actually another case in which <code>IReadOnlyCollection&lt;T&gt;</code> can be a good fit if you know your method is always going to return an <code>in-memory collection</code>.</p> <p>So It gives your caller the ability to access the count of items and iterate through as many times as they like.</p> <p>\u274c Bad With returning <code>IEnumerable&lt;Product&gt;</code>, We don\u2019t know the result is an in-memory operation or a potentially expensive action so It can be a risky operation with multiple enumeration. <pre><code>public IEnumerable&lt;Product&gt; GetAllProducts()\n{\n// ...\n}\n</code></pre></p> <p>\u2705 Good If we are sure, our result is a in-memory collection it is better we return a <code>IReadOnlyCollection&lt;Product&gt;</code> instead of <code>IEnumerable&lt;Product&gt;</code>. <pre><code>public IReadOnlyCollection&lt;Product&gt; GetAllProducts()\n{\n// ...\n}\n</code></pre></p>"},{"location":"collections/#dont-use-zero-length-arrays","title":"Don\u2019t use zero-length arrays","text":"<p>When initializing a zero-length array unnecessary memory allocation have to be made. Using <code>Array.Empty</code> can increase readability and reduce memory consumption as the memory is shared across all invocations of the method.</p> <p>\u274c Bad Return zero-initialized array. <pre><code>public int[] MyFunc(string input)\n{\nif (input == null)\nreturn new int[0];\n}\n</code></pre></p> <p>\u2705 Good Use <code>Array.Empty&lt;int&gt;</code> to increase readability and less allocations. <pre><code>public int[] MyFunc(string input)\n{\nif (input == null)\nreturn Array.Empty&lt;int&gt;();\n}\n</code></pre></p> <p>\ud83d\udca1 Info: For every generic version of <code>Array.Empty&lt;T&gt;</code> the instance and memory is shared. <pre><code>ReferenceEquals(new int[0], new int[0]); // Is false\nReferenceEquals(Array.Empty&lt;int&gt;(), Array.Empty&lt;int&gt;()); // Is true\nReferenceEquals(Array.Empty&lt;int&gt;(), Array.Empty&lt;float&gt;()); // Is false\n</code></pre></p>"},{"location":"collections/#specify-capacity-of-collections","title":"Specify capacity of collections","text":"<p>Often times collections like <code>List&lt;T&gt;</code> offer constructors, which give the option to pass in the expected capacity of the list. The <code>DefaultCapacity</code> of a list is 4. If added another item it will grow by the factor of 2. As the underlying structure of a <code>List&lt;T&gt;</code> is a conventional array and arrays can\u2019t shrink or grow in size, a new array has to be created with the new size plus the content of the old array. This takes times and needs to unnecessary allocations. This is especially important for hot paths.</p> <p>\u274c Bad No capacity is given so the internal array has to be resized often. <pre><code>var numbers = new List&lt;int&gt;();\nfor (var i = 0; i &lt; 20_000; i++)\nnumbers.Add(i);\n</code></pre></p> <p>\u2705 Good Capacity is given and the internal array of the <code>List&lt;T&gt;</code> has the correct size. <pre><code>var numbers = new List&lt;int&gt;(20_000);\nfor (var i = 0; i &lt; 20_000; i++)\nnumbers.Add(i);\n</code></pre></p>"},{"location":"collections/#benchmark","title":"Benchmark","text":"<p>Result of the given example above: <pre><code>|              Method |      Mean |    Error |   StdDev | Ratio | RatioSD |   Gen 0 |   Gen 1 |   Gen 2 | Allocated | Alloc Ratio |\n|-------------------- |----------:|---------:|---------:|------:|--------:|--------:|--------:|--------:|----------:|------------:|\n| ListWithoutCapacity | 102.64 us | 1.999 us | 3.340 us |  1.00 |    0.00 | 41.6260 | 41.6260 | 41.6260 | 256.36 KB |        1.00 |\n|    ListWithCapacity |  39.55 us | 0.789 us | 1.698 us |  0.38 |    0.02 | 18.8599 |       - |       - |  78.18 KB |        0.30 |\n</code></pre></p>"},{"location":"collections/#use-hashset-to-avoid-linear-searches","title":"Use <code>HashSet</code> to avoid linear searches","text":"<p>If a collection is used often times to check whether or not an item is present a <code>HashSet</code> might be a better option than a <code>List&lt;T&gt;</code>. The initial cost to create a <code>HashSet</code> is more expensive than a <code>List&lt;T&gt;</code> but set-based operations are faster. In this case this holds true even for <code>Any</code>, which is basically a linear search through the array.</p> <p>\u274c Bad If often checking for an item in a collection <code>Any</code> and <code>Contains</code> from <code>List&lt;T&gt;</code> can be slow. <pre><code>var userIds = Enumerable.Range(0, 1_000).ToList();\nusersIds.Any(u =&gt; u == 999); // Basically goes through 999 elements\nuserIds.Contains(999); // Faster than Any but still slower than HashSet\n</code></pre></p> <p>\u2705 Good <code>HashSet</code> performs faster for set-based operations. <pre><code>var userIds = Enumerable.Range(0, 1_000).ToHashSet();\nuserIds.Contains(999);\n</code></pre></p>"},{"location":"collections/#benchmark_1","title":"Benchmark","text":"<pre><code>public class ListVsHashSet\n{\nprivate const int Count = 10_000;\nprivate readonly List&lt;int&gt; _list = Enumerable.Range(0, Count).ToList();\nprivate readonly HashSet&lt;int&gt; _hashSet = Enumerable.Range(0, Count).ToHashSet();\n\n[Benchmark(Baseline = true)]\npublic bool ListContains() =&gt; _list.Contains(Count - 1);\n\n[Benchmark]\npublic bool ListAny() =&gt; _list.Any(l =&gt; l == Count - 1);\n\n[Benchmark]\npublic bool HashSetContains() =&gt; _hashSet.Contains(Count - 1);\n}\n</code></pre> <p>Results: <pre><code>|          Method |          Mean |         Error |        StdDev |  Ratio | RatioSD |\n|---------------- |--------------:|--------------:|--------------:|-------:|--------:|\n|    ListContains |  1,279.002 ns |    10.5561 ns |     9.3577 ns |  1.000 |    0.00 |\n|         ListAny | 92,892.521 ns | 1,848.0088 ns | 3,379.1886 ns | 75.344 |    2.48 |\n| HashSetContains |      5.019 ns |     0.1364 ns |     0.1401 ns |  0.004 |    0.00 |\n</code></pre></p>"},{"location":"collections/#use-hashset-for-set-based-operations-like-finding-the-intersection-of-two-collections","title":"Use <code>HashSet</code> for set based operations like finding the intersection of two collections","text":"<p>When performing set based operations like finding the intersection or union of two collection <code>HashSet</code> can be superior to a <code>List</code>. Be aware that the API is a bit different with a <code>HashSet</code> as the <code>HashSet</code> is not pure and modifies the <code>HashSet</code> on which the operation is called on.</p> <p>\u274c Bad Using LINQ and <code>List&lt;T&gt;</code> to find the intersection of two collectionss  <pre><code>var evenNumbers = Enumerable.Range(0, 2_000).Where(i =&gt; i % 2 == 0).ToList();\nvar dividableByThree = Enumerable.Range(0, 2_000).Where(i =&gt; i % 3 == 0).ToList();\n\nvar evenNumbersDividableByThree = evenNumbers.Intersect(dividableByThree).ToList();\n</code></pre></p> <p>\u2705 Good Using a <code>HashSet</code> to find the intersection of two collections. <pre><code>var evenNumbers = Enumerable.Range(0, 2_000).Where(i =&gt; i % 2 == 0).ToHashSet();\nvar dividableByThree = Enumerable.Range(0, 2_000).Where(i =&gt; i % 3 == 0).ToHashSet();\n\nvar evenNumbersDividableByThree = new HashSet(evenNumbers);\nevenNumbersDividableByThree.IntersectWith(dividableByThree);\n</code></pre></p>"},{"location":"collections/#benchmark_2","title":"Benchmark","text":"<p>Runtimes for the given example above:</p> <p>Result: <pre><code>|              Method |     Mean |    Error |   StdDev | Ratio |\n|-------------------- |---------:|---------:|---------:|------:|\n|    InterSectionList | 25.69 us | 0.416 us | 0.369 us |  1.00 |\n| InterSectionHashSet | 11.88 us | 0.108 us | 0.090 us |  0.46 |\n</code></pre></p>"},{"location":"collections/#use-arraysegmentt-for-efficient-slicing-of-arrays","title":"Use <code>ArraySegment&lt;T&gt;</code> for efficient slicing of arrays","text":"<p>When slicing an array a new array is created. This is especially expensive when the array is large. <code>ArraySegment&lt;T&gt;</code> is a struct that holds a reference to the original array and the start and end index of the slice. This is much more efficient than creating a new one. Be aware that the <code>ArraySegment&lt;T&gt;</code> is a read-only view of the original array and any changes to the original array will be reflected in the <code>ArraySegment&lt;T&gt;</code>.</p> <p>\u274c Bad We create a new array when taking a slice of the original array, leading to extra memory allocations.  <pre><code>public int[] Slice(int[] array, int offset, int count)\n{\nvar result = new int[count];\nArray.Copy(array, offset, result, 0, count);\nreturn result;\n}\n\nvar originalArray = new int[] { 1, 2, 3, 4, 5 };\nvar slicedArray = Slice(originalArray, 1, 3); // Creates a new array { 2, 3, 4 }\n</code></pre></p> <p>\u2705 Good Use <code>ArraySegment&lt;T&gt;</code> to create a view of the original array without creating a new array, avoiding the extra memory allocation. <pre><code>public ArraySegment&lt;int&gt; Slice(int[] array, int offset, int count)\n{\nreturn new ArraySegment&lt;int&gt;(array, offset, count);\n}\n\nvar originalArray = new int[] { 1, 2, 3, 4, 5 };\nvar slicedArray = Slice(originalArray, 1, 3); // A view over { 2, 3, 4 } in the original array\n</code></pre></p>"},{"location":"debugging/","title":"Debugging","text":"<p>This chapter looks into features, which can make debugging an application easier.</p>"},{"location":"debugging/#using-debuggerdisplayattribute","title":"Using <code>DebuggerDisplayAttribute</code>","text":"<p>The <code>DebuggerDisplayAttribute</code> determines how a class or structure is displayed in the debugger. This can save time if you have complex object, where you have a few key information, which are the most significant.</p> <pre><code>var steven = new Person(\"Steven\", 31, Array.Empty&lt;string&gt;());\nConsole.WriteLine(steven);\n\n[DebuggerDisplay(\"{Name} is {Age} years old with {PetNames.Count} pets.\")]\npublic record Person(string Name, int Age, IReadOnlyCollection&lt;string&gt; PetNames);\n</code></pre> <p>In the debugger window or if you hover over the <code>steven</code> object the debugger will show: <pre><code>Steven is 31 years old with 0 pets.\n</code></pre></p>"},{"location":"dictionary/","title":"<code>Dictionary</code>","text":"<p>This page will give some tips and tricks while handling the <code>Dictionary</code> type.</p>"},{"location":"dictionary/#safe-way-of-getting-a-key-from-a-dictionary","title":"Safe way of getting a key from a <code>Dictionary</code>","text":"<p>To get an element from a dictionary safely, we should check beforehand whether or not that element exists otherwise, we get an exception. Often times people use the <code>ContainsKey</code> method followed by the indexer of the dictionary. The problem here is that we do two lookups, even though we only need one (hashtable lookup). Also people find the second option more readable and it shows the intent better.</p> <p>\u274c Bad Use <code>ContainsKey</code> in combination with the indexer. <pre><code>Dictionary&lt;string, string&gt; mapping = GetMapping();\nif (mapping.ContainsKey(\"some-key\"))\n{\nvar value = mapping[\"some-key\"];\nDoSomethingWithValue(value);\n// ...\n}\n</code></pre></p> <p>\u2705 Good Avoid two lookups and get the value directly. <pre><code>Dictionary&lt;string, string&gt; mapping = GetMapping();\nif (mapping.TryGetValue(\"some-key\", out var value)\n{\nDoSomethingWithValue(value);\n// ...\n}\n</code></pre></p>"},{"location":"dictionary/#define-the-initial-size-when-creating-a-dictionary-when-known","title":"Define the initial size when creating a <code>Dictionary</code> when known","text":"<p><code>Dictionary</code> works internally a bit similiar to a <code>List</code>. Once a certain threshold of elements is reached, the internal type holding the information has to be resized. Resizing in this context means, create a new object of that type, which is bigger and copy all entries from the old storage into the new one. This operation is costly. When you build a <code>Dictionary</code> and the amount of entries is known, it is a better option to provide that capacity for the <code>Dictionary</code>.</p> <p>\u274c Bad Don\u2019t define the capacity, if known. <pre><code>var dictionary = new Dictionary&lt;string, string&gt;();\nforeach (var key in _keys)\ndictionary[key] = key;\n</code></pre></p> <p>\u2705 Good Defining the expected capacity. <pre><code>var dictionary = new Dictionary&lt;string, string&gt;(NumberOfKeys);\nforeach (var key in _keys) dictionary[key] = key;\n</code></pre></p>"},{"location":"dictionary/#benchmark","title":"Benchmark","text":"<pre><code>[MemoryDiagnoser()]\npublic class Benchmark\n{\nprivate List&lt;string&gt; _keys;\n\n[Params(5, 10, 100)]\npublic int NumberOfKeys { get; set; }\n\n[GlobalSetup]\npublic void Setup()\n{\n_keys = Enumerable.Range(0, NumberOfKeys).Select(n =&gt; n.ToString()).ToList();\n}\n\n[Benchmark(Baseline = true)]\npublic Dictionary&lt;string, string&gt; NoSize()\n{\nvar dictionary = new Dictionary&lt;string, string&gt;();\nforeach (var key in _keys) dictionary[key] = key;\n\nreturn dictionary;\n}\n\n[Benchmark]\npublic Dictionary&lt;string, string&gt; WithSize()\n{\nvar dictionary = new Dictionary&lt;string, string&gt;(NumberOfKeys);\nforeach (var key in _keys) dictionary[key] = key;\n\nreturn dictionary;\n}\n}\n</code></pre> <p>Result: <pre><code>|   Method | NumberOfKeys |        Mean |     Error |   StdDev | Ratio |   Gen0 | Allocated | Alloc Ratio |\n|--------- |------------- |------------:|----------:|---------:|------:|-------:|----------:|------------:|\n|   NoSize |            5 |   150.09 ns |  1.953 ns | 1.731 ns |  1.00 | 0.2217 |     464 B |        1.00 |\n| WithSize |            5 |    95.13 ns |  0.974 ns | 0.863 ns |  0.63 | 0.1568 |     328 B |        0.71 |\n|          |              |             |           |          |       |        |           |             |\n|   NoSize |           10 |   270.06 ns |  1.353 ns | 1.200 ns |  1.00 | 0.4740 |     992 B |        1.00 |\n| WithSize |           10 |   161.27 ns |  1.288 ns | 1.205 ns |  0.60 | 0.2103 |     440 B |        0.44 |\n|          |              |             |           |          |       |        |           |             |\n|   NoSize |          100 | 2,538.13 ns | 10.519 ns | 9.325 ns |  1.00 | 4.8714 |   10192 B |        1.00 |\n| WithSize |          100 | 1,574.53 ns |  8.705 ns | 7.717 ns |  0.62 | 1.4935 |    3128 B |        0.31 |\n</code></pre></p>"},{"location":"dictionary/#pass-in-stringcomparer-to-dictionary","title":"Pass in <code>StringComparer</code> to <code>Dictionary</code>","text":"<p><code>Dictionary</code> allows to pass in a <code>StringComparer</code> as a constructor argument. This allows for scenarios where you don\u2019t care about the case when retrieving a key from the dictionary. It also elimnates all the <code>ToUpper</code> or <code>ToLower</code> calls. Bonus points as it is slight more performant.</p> <p>\u274c Bad Using <code>ToLower</code> or <code>ToUpper</code> to be case insensitive. <pre><code>var myDictionary = new Dictionary&lt;string, int&gt;()\n{\n{ \"foo\", 1 },\n{ \"bar\", 2 }\n}\n\n_ = myDictionary.ContainsKey(\"Foo\"); // false\n_ = myDictionary.ContainsKey(\"Foo\".ToLower()); // true\n_ = myDictionary.ContainsKey(\"foo\"); // true\n</code></pre></p> <p>\u2705 Good Pass in a <code>StringComparer</code> to the constructor. <pre><code>var myDictionary = new Dictionary&lt;string, int&gt;(StringComparer.OrdinalIgnoreCase)\n{\n{ \"foo\", 1 },\n{ \"bar\", 2 }\n}\n\n_ = myDictionary.ContainsKey(\"Foo\"); // true\n_ = myDictionary.ContainsKey(\"FOO\"); // true\n_ = myDictionary.ContainsKey(\"foo\"); // true\n</code></pre></p>"},{"location":"exceptions/","title":"Exceptions","text":"<p>This chapter looks closer to exceptions and how exceptions are handled.</p>"},{"location":"exceptions/#re-throwing-exceptions-incorrectly","title":"Re-throwing exceptions incorrectly","text":"<p>If done the wrong way, the stack trace including valuable information is gone.</p> <p>\u274c Bad Throwing the original object again will create a new stack trace <pre><code>try\n{\n// logic which can throw here\n}\ncatch (Exception exc)\n{\nthrow exc;\n}\n</code></pre></p> <p>\u26a0\ufe0f Warning Creating a new exception object with the original as <code>InnerException</code> but a new stack trace which can make debugging harder. <pre><code>try\n{\n// logic which can throw here\n}\ncatch (Exception exc)\n{\nthrow new Exception(\"A message here\", exc);\n}\n</code></pre></p> <p>\u2705 Good Simply <code>throw</code> the exception to preserve the original stack trace. <pre><code>try\n{\n// logic which can throw here\n}\ncatch (Exception exc)\n{\n// Logic like logging here\nthrow;\n}\n</code></pre></p> <p>\ud83d\udca1 Info: Sometimes hiding the original stack trace might be the goal due to for example security related reasons. In the average case re-throwing via <code>throw;</code> is preferred.</p>"},{"location":"exceptions/#pokemon-exception-handling","title":"Pokemon Exception Handling","text":"<p>Indiscriminately catching exceptions. \u201cPokemon - gotta catch \u2018em all\u201d</p> <p>\u274c Bad Catching every exception and gracefully swallowing it. <pre><code>try\n{\nMyOperation();\n}\ncatch (Exception exc)\n{\n// Do nothing\n}\n</code></pre></p> <p>Also: <pre><code>try\n{\nMyOperation();\n}\ncatch\n{\n// Do nothing\n}\n</code></pre></p> <p>\u2705 Good Catch the specific exception one would expect and handle it. <pre><code>try\n{\nMyOperation();\n}\ncatch (InvalidOperationException exc)\n{\nlogger.Log(exc);\n// More logic here and if wished re-throw the exception\nthrow; }\n</code></pre></p>"},{"location":"exceptions/#throwing-nullreferenceexception-indexoutofrangeexception-and-accessviolationexception","title":"Throwing <code>NullReferenceException</code>, <code>IndexOutOfRangeException</code>, and <code>AccessViolationException</code>","text":"<p>This exceptions should not be thrown in public API\u2019s. The reasoning is that those exceptions should only be thrown by the runtime and normally indicate a bug in the software. For example one can avoid <code>NullReferenceException</code> by checking the object if it is <code>null</code> or not. On almost any case there different exceptions one can utilize, which have more semantic.</p> <p>\u274c Bad Throw <code>NullReferenceException</code> when checking a parameter. <pre><code>public void DoSomething(string name)\n{\nif (name == null)\n{\nthrow new NullReferenceException();\n}\n</code></pre></p> <p>\u2705 Good Indicating the argument is null and use the proper exception. <pre><code>public void DoSomething(string name)\n{\nArgumentNullException.ThrowIfNull(name);\n}\n</code></pre></p> <p>\ud83d\udca1 Info: More details can be found here.</p>"},{"location":"exceptions/#dont-throw-stackoverflowexception-or-outofmemoryexception","title":"Don\u2019t throw <code>StackOverflowException</code> or <code>OutOfMemoryException</code>","text":"<p>Both exceptions are meant only to be thrown from the runtime itself. Under normal circumstances recovering from a <code>StackOverflow</code> is hard to impossible. Therefore catching a <code>StackOverflowException</code> should also be avoided. And can catch <code>OutOfMemoryException</code> as they can also occur if a big array gets allocated but no more free space is available. That does not necessarily mean recovering from this is impossible.</p> <p>\ud83d\udca1 Info: More details can be found here.</p>"},{"location":"exceptions/#exception-filtering-with-when","title":"Exception filtering with <code>when</code>","text":"<p>The <code>when</code> expression was introduced with C# 6 and allows a more readable way of filtering exceptions.</p> <p>\u274c Bad Less readable way. <pre><code>try\n{\nawait GetApiRequestAsync();\n}\ncatch (HttpRequestException e)\n{\nif (e.StatusCode == HttpStatusCode.BadRequest)\n{\nHandleBadRequest(e);\n}\nelse if (e.StatusCode == HttpStatusCode.NotFound)\n{\nHandleNotFound(e);\n}\n}\n</code></pre></p> <p>\u2705 Good More readable way. <pre><code>try\n{\nawait GetApiRequestAsync();\n}\ncatch (HttpRequestException e) when (e.StatusCode == HttpStatusCode.BadRequest)\n{\nHandleBadRequest(e);\n}\ncatch (HttpRequestException e) when (e.StatusCode == HttpStatusCode.NotFound)\n{\nHandleNotFound(e);\n}\n</code></pre></p>"},{"location":"exceptions/#finalizers-should-not-throw-exceptions","title":"Finalizers should not throw exceptions","text":"<p>Throwing an exception in a finalizer can lead to an immediate shutdown of the application without any cleanup.</p> <p>\u274c Bad Throwing an exception in the finalizer.  <pre><code>class MyClass\n{\n~MyClass()\n{\nthrow new NotImplementedException();\n}\n}\n</code></pre></p> <p>\u2705 Good Don\u2019t throw exceptions. <pre><code>class MyClass\n{\n~MyClass()\n{\n}\n}\n</code></pre></p> <p>\ud83d\udca1 Info: More details can be found here.</p>"},{"location":"exceptions/#preserving-the-stack-trace-of-an-exception","title":"Preserving the stack trace of an exception","text":"<p>When catching an exception and re-throwing the exception via <code>throw exc</code> later the stack-trace gets altered, but sometimes capturing the exception can make sense. Since the .NET Framework 4.5 there is a small helper named <code>ExceptionDispatchInfo</code>, which let\u2019s you preserve that information. It offers a <code>Throw</code> method, which re-throws the saved exception with the given stack-trace.</p> <p>\u274c Bad Re-throwing the exception while losing the stack-trace <pre><code>Exception? exception = null;\n\ntry\n{\nThrows();\n}\ncatch (Exception exc)\n{\nexception = exc;\n}\n\n// Do something here ...\n\nif (exception is not null)\nthrow exception;\n\nvoid Throws() =&gt; throw new Exception(\"\ud83d\udca3\");\n</code></pre></p> <p>Produces the following output: <pre><code>Unhandled exception. System.Exception: \ud83d\udca3\n   at Program.&lt;Main&gt;$(String[] args) in /Users/stgi/repos/Exception/Program.cs:line 15\n</code></pre></p> <p>\u2705 Good Capturing the context to re-throw it later. <pre><code>using System.Runtime.ExceptionServices;\n\nExceptionDispatchInfo? exceptionDispatchInfo;\n\ntry\n{\nThrows();\n}\ncatch (Exception exc)\n{\nexceptionDispatchInfo = ExceptionDispatchInfo.Capture(exc);\n}\n\n// Do something here ...\n\nif (exceptionDispatchInfo is not null)\nexceptionDispatchInfo.Throw();\n\nvoid Throws() =&gt; throw new Exception(\"\ud83d\udca3\");\n</code></pre></p> <p>Produces the following output: <pre><code>Unhandled exception. System.Exception: \ud83d\udca3\n   at Program.&lt;&lt;Main&gt;$&gt;g__Throws|0_0() in /Users/stgi/repos/Exception/Program.cs:line 19\n   at Program.&lt;Main&gt;$(String[] args) in /Users/stgi/repos/Exception/Program.cs:line 7\n--- End of stack trace from previous location ---\n   at Program.&lt;Main&gt;$(String[] args) in /Users/stgi/repos/Exception/Program.cs:line 17\n</code></pre></p>"},{"location":"linq/","title":"LINQ","text":"<p>This chapter will handle topics about LINQ.</p>"},{"location":"linq/#using-is-and-as-instead-of-oftype","title":"Using <code>is</code> and <code>as</code> instead of <code>OfType</code>","text":"<p>Using <code>is</code> and <code>as</code> cast should not be used in LINQ as it degrades readability and to some extend also performance (neglactable small under normal circumstances).</p> <p>\u274c Bad Less readable and unnecessary casts. <pre><code>persons.Where(p =&gt; p is FullTimeEmployee).Select(p =&gt; p as FullTimeEmployee);\npersons.Where(p =&gt; p is FullTimeEmployee).Select(p =&gt; (FullTimeEmployee)p);\npersons.Select(p =&gt; p as FullTimeEmployee).Where(p =&gt; p != null);\n</code></pre></p> <p>\u2705 Good Using <code>OfType</code> is cleaner and more readable. <pre><code>persons.OfType&lt;FullTimeEmployee&gt;();\n</code></pre></p>"},{"location":"linq/#using-count-instead-of-all-or-any","title":"Using <code>Count()</code> instead of <code>All</code> or <code>Any</code>","text":"<p>The problem with <code>Count()</code> is that LINQ has to enumerate every single entry in the enumeration to get the full count, where as <code>Any</code>/<code>All</code> would return immediately as soon as the condition is not satisfied anymore. In general conditions (excluding LINQ to SQL) <code>Any</code>/<code>All</code> in the worst case have the same runtime as <code>Count</code> but in best and average cases they are faster and more readable.</p> <p>\u274c Bad Less readable and unnecessary enumerations  <pre><code>persons.Count() &gt; 0\npersons.Count(MyPredicate) &gt; 0\npersons.Count(MyPredicate) == 0\npersons.Count(MyPredicate) == persons.Count()\n</code></pre></p> <p>\u2705 Good More readable and avoids unnecessary enumerations <pre><code>persons.Any()\npersons.Any(MyPredicate)\n!persons.Any(MyPredicate)\npersons.All(MyPredicate)\n</code></pre></p>"},{"location":"misc/","title":"Misc","text":"<p>A collection of different topics which didn\u2019t fit in the other categories.</p>"},{"location":"misc/#new-random-in-a-loop","title":"<code>new Random</code> in a loop","text":"<p>\ud83d\udca1 Info: This part is only valid for the old .NET Framework and not the newer .NET Core / .NET 5 or 6 versions.</p> <p>In the .NET Framework creating the <code>Random</code> class without any parameter in very short time spans will create identical outputs. Especially in for loops this can result in the same number over and over again. If no seed is provided for the <code>Random</code> class, it will create a seed which is time dependent. The resolution of the timer is depending on the implementation of the underlying OS. On most windows system the resolution is 15ms.</p> <p>\u274c Bad Will produce the same number 3 times. <pre><code>for(var i = 0; i &lt; 3; i++)\n{\nvar random = new Random();\nvar number = random.Next(6);\nConsole.WriteLine(number);\n}\n</code></pre></p> <p>Prints:</p> <p>4 4 4</p> <p>\u2705 Good Extract the creation of the <code>Random</code> class outside the loop. <pre><code>var random = new Random();\n\nfor(var i = 0; i &lt; 3; i++)\n{   \n    var number = random.Next(6);\n    Console.WriteLine(number);\n}\n</code></pre></p> <p>Prints:</p> <p>5 3 5</p>"},{"location":"misc/#implementing-gethashcode","title":"Implementing <code>GetHashCode</code>","text":"<p><code>GetHashCode</code> is mainly used for <code>Dictionary</code>. Mainly two things are important to say an object (at least from an dictionary point of view) is equal:  * <code>GetHashCode</code> for two objects are the same and:  * <code>Equals</code> is the same.</p> <p>Dotnet does the first because its cheaper to calculate hashes and only if they match to check if the object is really the same.</p> <p>\u274c Bad GetHashCode which can cause collision <pre><code>public class Point\n{\npublic int X { get; set; }\npublic int Y { get; set; }\n\npublic override int GetHashCode() =&gt; X + Y; // Can lead to massive collisions\n}\n</code></pre></p> <p>\u2705 Good Since .netcore there is a helper class called: <code>HashCode.Combine</code>. <pre><code>public class Point\n{\npublic int X { get; set; }\npublic int Y { get; set; }\n\npublic override int GetHashCode() =&gt; HashCode.Combine(X, Y);\n}\n</code></pre></p> <p>\u2705 Good Also <code>ValueTuple</code> can be used for that purpose (since C# 7). <pre><code>public class Point\n{\npublic int X { get; set; }\npublic int Y { get; set; }\n\npublic override int GetHashCode() =&gt; (X, Y).GetHashCode();\n}\n</code></pre></p>"},{"location":"misc/#virtual-member-calls-in-constructor","title":"Virtual member calls in constructor","text":"<p>Calling a virtual member in a constructor can lead to unexpected behavior. The reason is that initializers run from most derived to base type but constructors run from base constructor to most derived.</p> <p>\u274c Bad This example will lead to a <code>NullReferenceException</code> <pre><code>public class Parent\n{\npublic Parent() { Console.WriteLine(GetType().Name); PrintHello(); }\npublic virtual void PrintHello() {}\n}\n\npublic class Child : Parent\n{\nprivate string foo; public Child()\n{\nfoo = \"Something\";\n}\n\npublic override void PrintHello()\n{\n// foo will be null as it gets called in the base constructor before \"our\"\n// Child constructor is called and initializes the state\nConsole.WriteLine(foo.ToUpperInvariant());\n}\n}\n</code></pre> Output:</p> <p>Child Unhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.</p> <p>\u2705 Good Avoid virtual member calls via sealing the class or don\u2019t make the method virtual. <pre><code>public class Parent\n{\npublic Parent() { Console.WriteLine(GetType().Name); PrintHello(); }\npublic void PrintHello() {}\n}\n\npublic class Child : Parent\n{\nprivate string foo; public Child()\n{\n\nfoo = \"Something\";\n}\n}\n</code></pre></p> <p>\ud83d\udca1 Info: It is perfectly fine to call a virtual member if the caller is the most derived type in the chain and there can\u2019t be another derived type (therefore the class is <code>sealed</code>).</p>"},{"location":"misc/#dont-have-empty-finalizers","title":"Don\u2019t have empty finalizers","text":"<p>An empty finalizer does not offer any functionality and also decreases performance. Objects have to live at least one more generation before they can be removed.</p> <p>\u274c Bad Empty finalizer defined. <pre><code>public class MyClass\n{\n~MyClass() {}\n}\n</code></pre></p> <p>\u2705 Good Don\u2019t define an empty finalizer. <pre><code>public class MyClass\n{\n\n}\n</code></pre></p> <p>\ud83d\udca1 Info: More information can be found here.</p>"},{"location":"misc/#benchmark","title":"Benchmark","text":"<p>Results for the given example above: <pre><code>|             Method |       Mean |     Error |    StdDev | Ratio | RatioSD |  Gen 0 |  Gen 1 | Allocated |\n|------------------- |-----------:|----------:|----------:|------:|--------:|-------:|-------:|----------:|\n|   WithoutFinalizer |   2.205 ns | 0.1230 ns | 0.1416 ns |  1.00 |    0.00 | 0.0057 |      - |      24 B |\n| WithEmptyFinalizer | 144.038 ns | 2.9594 ns | 6.1773 ns | 65.32 |    4.19 | 0.0057 | 0.0029 |      24 B |\n</code></pre></p>"},{"location":"misc/#enumtryparse-unexpected-behavior","title":"<code>Enum.TryParse</code> unexpected behavior","text":"<p><code>Enum.TryParse</code> parses a string and tries to convert it into a valid representation of a given enum. If the operation is successful it returns <code>true</code>, otherwise <code>false</code>. Have a look at the following code. What will be the output of that code? </p> <pre><code>var couldParse = Enum.TryParse(\"3\", out WeekendDay weekendDay);\n\nConsole.WriteLine($\"Could parse: {couldParse}\");\nConsole.WriteLine($\"Value: {weekendDay}\");\n\npublic enum WeekendDay\n{\nSaturday = 0,\nSunday = 1,\n}\n</code></pre> <p><code>3</code> is not a valid <code>WeekendDay</code> therefore <code>false</code> sure thing. But unfortunately no. The output is </p> <p>Could parse: true Value: 3</p> <p>You can try this on out sharplab.io if you want.</p> <p>\u2705 Good Use <code>Enum.IsDefined</code> to check if a given value is in the correct range. With <code>Enum.IsDefined</code> we can check if the value is correct for a given enum.</p> <pre><code>var couldParse = Enum.TryParse(\"3\", out WeekendDay weekendDay);\nif (couldParse &amp;&amp; Enum.IsDefined(typeof(WeekendDay), weekendDay))\n{\n// Only here we have a valid value for WeekendDay\n}\n</code></pre>"},{"location":"misc/#be-careful-of-closures","title":"Be careful of closures","text":"<p>Closures are \u201cattached\u201d to their parent to close over a certain variable. Basically the anonymous function / lambda is taking an argument outside of his own scope. The following code demonstrates such behavior: <pre><code>var list = new List&lt;Action&gt;();\n\nfor(var i = 0; i &lt; 5; i++)\nlist.Add(() =&gt; Console.WriteLine(i));\n\nlist.ForEach(action =&gt; action());\n</code></pre></p> <p>And here is the pitfall. The snippet might print something unexpecting: <pre><code>5\n5\n5\n5\n5\n</code></pre> The reason is that behind the scenes the closures creates an anonymous class, which holds a reference to <code>i</code> (instead if a copy). That will lead to that all <code>Action</code>s point to the same reference of <code>i</code>, which after the for loop is <code>5</code>. The way to fix this is the following:</p> <pre><code>var list = new List&lt;Action&gt;();\n\nfor (var i = 0; i &lt; 5; i++)\n{\nvar t = i;\nlist.Add(() =&gt; Console.WriteLine(t));\n}\n\nlist.ForEach(action =&gt; action());\n</code></pre> <p>This works because copying an interger to a temporary variable will result in a new reference behind the scenes. You can fiddle around with that example on sharplab.io.</p> <p>Additionally adding the <code>static</code> keyword to an anonymous function will prohibit any closures. So <code>list.Add(() =&gt; Console.WriteLine(i));</code> will result in an compiler error.</p>"},{"location":"strings/","title":"strings","text":"<p>This chapter shows some tips, tricks and pitfalls in combination with <code>string</code>\u2018s.</p>"},{"location":"strings/#use-stringbuilder-when-concatenating-a-lot-of-strings","title":"Use <code>StringBuilder</code> when concatenating a lot of strings","text":"<p>As <code>string</code>\u2018s are immutable in C# concatenating those will result in many allocations and loss of performance. In scenarios where many strings get concatenated a <code>StringBuilder</code> is preferred. The same applies to operations like <code>string.Join</code> or add a single character to a <code>string</code>.</p> <p>\u274c Bad Will use a lot of allocations and will result in a performance penalty. <pre><code>var outputString = \"\";\n\nfor (var i = 0; i &lt; 25; i++)\n{\noutputString += \"test\" + i;\n}\n</code></pre></p> <p>\u2705 Good Usage of <code>StringBuilder</code> will reduce the allocations dramatically and also performs better. Here is a comparison of both methods:</p> <pre><code>|              Method | Times |        Mean |     Error |      StdDev |      Median | Ratio | RatioSD |   Gen 0 | Allocated |\n|-------------------- |------ |------------:|----------:|------------:|------------:|------:|--------:|--------:|----------:|\n|        StringConcat |    10 |    298.7 ns |   1.86 ns |     1.45 ns |    298.3 ns |  1.00 |    0.00 |  0.4549 |      2 KB |\n| StringBuilderAppend |    10 |    436.2 ns |   5.31 ns |     4.15 ns |    437.1 ns |  1.46 |    0.02 |  0.4206 |      2 KB |\n|                     |       |             |           |             |             |       |         |         |           |\n|        StringConcat |   100 | 15,025.7 ns | 739.33 ns | 2,011.40 ns | 14,579.0 ns |  1.00 |    0.00 | 39.5203 |    161 KB |\n| StringBuilderAppend |   100 |  5,989.5 ns | 415.73 ns | 1,225.78 ns |  6,416.1 ns |  0.41 |    0.12 |  3.9063 |     16 KB |\n</code></pre>"},{"location":"strings/#getting-the-printable-length-of-a-string-or-character","title":"Getting the printable length of a string or character","text":"<p>Retrieving the length of a string can often be done via <code>\"my string\".Length</code>, which in a lot of scenarios is good enough. Under the hood <code>string.Length</code> will return the number of characters in this string object. Unfortunately that does not always map one to one with the printed characters on screen.</p> <p>\u274c Bad Assuming every printed characters has the same length. <pre><code>Console.Write(\"The following string has the length of 1: \");\nConsole.WriteLine(\"\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f\".Length);\n</code></pre></p> <p>Output:</p> <p>The following string has the length of 1: 14</p> <p>Emojis can consist out of \u201cother\u201d emojis making the length very variable. Also other charaters like the following are wider: <pre><code>Console.WriteLine(\"\ud835\udd99\ud835\udd8d\ud835\udd8e\ud835\udd98\".Length); // Prints 8\n</code></pre></p> <p>\u2705 Good Take <code>StringInfo.LengthInTextElements</code> to know the amount of printed characters. <pre><code>Console.WriteLine(new StringInfo(\"\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f\").LengthInTextElements);\n</code></pre></p> <p>Output:</p> <p>1</p> <p>To summarize: <code>string.Length</code> will give return the internal array size not the length of printed characters. <code>StringInfo.LengthInTextElements</code> will return the amount of printed characters.</p> <p>\ud83d\udca1 Info: Some more information about Unicode, UTF-8, UTF-16 and UTF-32 can be found here.</p>"},{"location":"strings/#use-stringcomparison-instead-of-tolowercase-or-touppercase-for-insensitive-comparison","title":"Use <code>StringComparison</code> instead of <code>ToLowerCase</code> or <code>ToUpperCase</code> for insensitive comparison","text":"<p>Lots of code is using <code>\"ABC\".ToLowerCase() == \"abc\".ToLowerCase()</code> to compare two strings, when casing doesn\u2019t matter. The problem with that code is <code>ToLowerCase</code> as well as <code>ToUpperCase</code> creates a new string instance, resulting in unnecessary allocations and performance loss. </p> <p>\u274c Bad Using new allocations for comparing strings. <pre><code>var areStringsEqual = \"abc\".ToUpperCase() == \"ABC\".ToUpperCase();\n</code></pre></p> <p>\u2705 Good Use of the <code>string.Equals</code> overload with the appropriate <code>StringComparison</code> technique. <pre><code>var areStringsEqual = string.Equals(\"ABC\", \"abc\", StringComparison.OrdinalIgnoreCase);\n</code></pre></p>"},{"location":"strings/#benchmark","title":"Benchmark","text":"<pre><code>[MemoryDiagnoser]\n[HideColumns(Column.Arguments)]\npublic class StringBenchmark\n{\n[Benchmark(Baseline = true)]\n[Arguments(\n        \"HellO WoRLD, how are you? You are doing good?\",\n        \"hElLO wOrLD, how Are you? you are doing good?\")]\npublic bool AreEqualToLower(string a, string b) =&gt; a.ToLower() == b.ToLower();\n\n[Benchmark(Baseline = false)]\n[Arguments(\n        \"HellO WoRLD, how are you? You are doing good?\",\n        \"hElLO wOrLD, how Are you? you are doing good?\")]\npublic bool AreEqualStringComparison(string a, string b) =&gt; string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n}\n</code></pre> <p>Results: <pre><code>|                   Method |     Mean |    Error |   StdDev | Ratio |   Gen0 | Allocated | Alloc Ratio |\n|------------------------- |---------:|---------:|---------:|------:|-------:|----------:|------------:|\n|          AreEqualToLower | 60.93 ns | 1.008 ns | 0.943 ns |  1.00 | 0.0356 |     224 B |        1.00 |\n| AreEqualStringComparison | 16.10 ns | 0.030 ns | 0.028 ns |  0.26 |      - |         - |        0.00 |\n</code></pre></p>"},{"location":"strings/#prefer-startswith-over-indexof-0","title":"Prefer <code>StartsWith</code> over <code>IndexOf() == 0</code>","text":"<p>The problem with IndexOf is, that it will go through the whole string in the worst case. StartsWith on the contrary will directly abort one the first mismatch.</p> <p>\u274c Bad Using <code>IndexOf</code> which might run through the whole string. <pre><code>var startsWithHallo = \"Hello World\".IndexOf(\"Hallo\") == 0;\n</code></pre></p> <p>\u2705 Good More readable, as well as more performant with <code>StartsWith</code>. <pre><code>var startsWithHallo = \"Hello World\".StartsWith(\"Hallo\");\n</code></pre></p>"},{"location":"strings/#benchmark_1","title":"Benchmark","text":"<pre><code>[Benchmark(Baseline = true)]\n[Arguments(\"That is a sentence\", \"Thzt\")]\npublic bool IndexOf(string haystack, string needle) =&gt; haystack.IndexOf(needle, StringComparison.OrdinalIgnoreCase) == 0;\n\n[Benchmark]\n[Arguments(\"That is a sentence\", \"Thzt\")]\npublic bool StartsWith(string haystack, string needle) =&gt;\nhaystack.StartsWith(needle, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Results: <pre><code>|     Method |           haystack | needle |      Mean |     Error |    StdDev | Ratio |\n|----------- |------------------- |------- |----------:|----------:|----------:|------:|\n|    IndexOf | That is a sentence |   Thzt | 21.966 ns | 0.1584 ns | 0.1482 ns |  1.00 |\n| StartsWith | That is a sentence |   Thzt |  3.066 ns | 0.0142 ns | 0.0126 ns |  0.14 |\n</code></pre></p>"},{"location":"strings/#prefer-asspan-over-substring","title":"Prefer <code>AsSpan</code> over <code>Substring</code>","text":"<p><code>Substring</code> always allocates a new string object on the heap. If you have a method that accepts a <code>Span&lt;char&gt;</code> or <code>ReadOnlySpan&lt;char&gt;</code> you can avoid these allocations. A prime example is <code>string.Concat</code> that takes a <code>ReadOnlySpan&lt;char&gt;</code> as an input parameter.</p> <p>\u274c Bad Creating new <code>string</code> objects that are directly discarded afterward. <pre><code>var output = Text.Substring(0, 5) + \" - \" + Text.Substring(11, 4);\n</code></pre></p> <p>\u2705 Good Directly use the underlying memory to avoid heap allocations. <pre><code>var output = string.Concat(Text.AsSpan(0, 5), \" - \", Text.AsSpan(11, 4));\n</code></pre></p>"},{"location":"strings/#benchmark_2","title":"Benchmark","text":"<pre><code>[MemoryDiagnoser]\npublic class Benchmark\n{\n[Params(\"Hello dear world\")]\npublic string Text { get; set; }\n\n[Benchmark]\npublic string Substring()\n=&gt; Text.Substring(0, 5) + \" - \" + Text.Substring(11, 4);\n\n[Benchmark]\npublic string AsSpanConcat()\n=&gt; string.Concat(Text.AsSpan(0, 5), \" - \", Text.AsSpan(11, 4));\n}\n</code></pre> <p>Results: <pre><code>|       Method |             Text |     Mean |    Error |   StdDev |   Gen0 | Allocated |\n|------------- |----------------- |---------:|---------:|---------:|-------:|----------:|\n|    Substring | Hello dear world | 21.18 ns | 0.085 ns | 0.076 ns | 0.0179 |     112 B |\n| AsSpanConcat | Hello dear world | 10.20 ns | 0.021 ns | 0.018 ns | 0.0076 |      48 B |\n</code></pre></p>"},{"location":"valuetuple/","title":"ValueTuple","text":"<p>This section looks into tips and tricks of the <code>ValueTuple</code> type which was introduced in C# 7.</p>"},{"location":"valuetuple/#easy-iequatable-implementation","title":"Easy <code>IEquatable</code> implementation","text":"<p><code>ValueTuple</code> can be leveraged to have an easy and readable implementation of <code>IEquatable</code>.</p> <pre><code>public class Dimension : IEquatable&lt;Dimension&gt;\n{\npublic Dimension(int width, int height)\n=&gt; (Width, Height) = (width, height);\n\npublic int Width { get; }\npublic int Height { get; }\n\npublic bool Equals(Dimension other)\n=&gt; (Width, Height) == (other?.Width, other?.Height);\n\npublic override bool Equals(object obj)\n=&gt; obj is Dimension dimension &amp;&amp; Equals(dimension);\n\npublic override int GetHashCode() =&gt; (Width, Height).GetHashCode();\n}\n</code></pre>"},{"location":"valuetuple/#swap-two-values","title":"Swap two values","text":"<p><code>ValueTuple</code> can be used to swap two (or more) variables without the usage of a temporary variable.</p> <p>\u274c Bad Using temporary variable. <pre><code>int a = 10;\nint b = 15;\n\nvar tmp = a;\na = b;\nb = tmp;\n</code></pre></p> <p>\u2705 Good Using <code>ValueTuple</code>. <pre><code>int a = 10;\nint b = 15;\n\n(a, b) = (b, a);\n</code></pre></p>"},{"location":"advanced/","title":"Advanced","text":"<p>Here you will find more advanced techniques which are not meant for everyday use. This could be for example very minor optimization for hot paths which try to reduce every millisecond and every byte of allocation. The tips will most likely increase complexity and decrease readability in the source code. </p> <p>As always measure the specific scenario first and act according to the results.</p>"},{"location":"advanced/SIMD/","title":"SIMD - Single Input Multiple Data","text":"<p>SIMD describes the ability the process a single operation simultaneously on multiple data. This can give a big edge on independent data which can be processed in parallel. More information can be found here.</p>"},{"location":"advanced/SIMD/#compare-two-lists-with-simd","title":"Compare two lists with SIMD","text":"<p>To speed-up the process of two lists, we can vectorize those lists and compare multiple chunks in parallel. To vectorize a list we can use SSE (S IMD S treaming E xtensions) in combination with some helper tools from the .NET Framework itself.</p> <p>\u274c Bad Use LINQ queries, which can be slow. <pre><code>var isEqual = list1.SequenceEquals(list2);\n</code></pre></p> <p>\u2705 Good Use SSE to vectorize the list and check in parallel if the chunks are the same. <pre><code>public bool SIMDContains()\n{\n// Lists are not equal when the count is different\nif (list1.Count != list2.Count)\nreturn false;\n\n// Create a Span&lt;Vector&lt;int&gt;&gt; from our original list.\n// We don't have to worry about the internal size, etc...\nvar list1AsVector = MemoryMarshal.Cast&lt;int, Vector&lt;int&gt;&gt;(CollectionsMarshal.AsSpan(list1));\nvar list2AsVector = MemoryMarshal.Cast&lt;int, Vector&lt;int&gt;&gt;(CollectionsMarshal.AsSpan(list2));\n\nfor (var i = 0; i &lt; list1AsVector.Length; i++)\n{\n// Compare the chunks of list1 and list2\nif (!Vector.EqualsAll(list1AsVector[i], list2AsVector[i]))\nreturn false;\n}\n\nreturn true;\n}\n</code></pre></p> <p>\ud83d\udca1 Info: Check with <code>Vector.IsHardwareAccelerated</code> if SSE is available. If not the emulated / software version can be slower than LINQ due to the overhead.</p>"},{"location":"advanced/SIMD/#benchmark","title":"Benchmark","text":"<pre><code>public class Benchmark\n{\nprivate readonly List&lt;int&gt; list1 = Enumerable.Range(0, 1_000).ToList();\nprivate readonly List&lt;int&gt; list2 = Enumerable.Range(0, 1_000).ToList();\n\n[Benchmark(Baseline = true)]\npublic bool LINQSequenceEquals() =&gt; list1.SequenceEqual(list2);\n\n[Benchmark]\npublic bool SIMDEquals()\n{\nif (list1.Count != list2.Count)\nreturn false;\n\nvar list1AsVector = MemoryMarshal.Cast&lt;int, Vector&lt;int&gt;&gt;(CollectionsMarshal.AsSpan(list1));\nvar list2AsVector = MemoryMarshal.Cast&lt;int, Vector&lt;int&gt;&gt;(CollectionsMarshal.AsSpan(list2));\n\nfor (var i = 0; i &lt; list1AsVector.Length; i++)\n{\nif (!Vector.EqualsAll(list1AsVector[i], list2AsVector[i]))\nreturn false;\n}\n\nreturn true;\n}\n}\n</code></pre> <p>Results: <pre><code>|             Method |       Mean |    Error |   StdDev | Ratio |\n|------------------- |-----------:|---------:|---------:|------:|\n| LINQSequenceEquals | 3,487.4 ns | 13.72 ns | 10.71 ns |  1.00 |\n|         SIMDEquals |   137.3 ns |  0.98 ns |  0.91 ns |  0.04 |\n</code></pre></p>"},{"location":"advanced/SIMD/#get-the-sum-of-a-list-or-array","title":"Get the sum of a list or array","text":"<p>SIMD can be used to divide and conquer the problem of retrieving the sum of a list. The idea is to cut the list in smaller chunks and add them up via SIMD instuctions. This approach can faster the speed significantly.</p> <p>\u274c Bad Using plain old LINQ to get a sum of a list or array of integers. <pre><code>_list.Sum();\n</code></pre></p> <p>\u2705 Good Using SIMD instructions to divide and conquer and parallelize the addition of the individual vectors. <pre><code>public int SumSIMD()\n{\nvar accVector = Vector&lt;int&gt;.Zero;\n\n// For any array use\n// var spanOfVectors = MemoryMarshal.Cast&lt;int, Vector&lt;int&gt;&gt;(new Span&lt;int&gt;(myArray));\nvar spanOfVectors = MemoryMarshal.Cast&lt;int, Vector&lt;int&gt;&gt;(CollectionsMarshal.AsSpan(_list));\nforeach (var vector in spanOfVectors)\n{\naccVector = Vector.Add(accVector, vector);\n}\n\n// Scalar-Product of our vector against the Unit vector is its sum\nvar result = Vector.Dot(accVector, Vector&lt;int&gt;.One);\nreturn result;\n}\n</code></pre></p>"},{"location":"advanced/SIMD/#benchmark_1","title":"Benchmark","text":"<p><pre><code>public class Benchmark\n{\nprivate readonly List&lt;int&gt; _list = Enumerable.Range(0, 1_000).ToList();\n\n[Benchmark(Baseline = true)]\npublic int ListSum() =&gt; _list.Sum();\n\n[Benchmark]\npublic int SumSIMD()\n{\nvar accVector = Vector&lt;int&gt;.Zero;\n\n// For any array use\n// var spanOfVectors = MemoryMarshal.Cast&lt;int, Vector&lt;int&gt;&gt;(new Span&lt;int&gt;(myArray));\nvar spanOfVectors = MemoryMarshal.Cast&lt;int, Vector&lt;int&gt;&gt;(CollectionsMarshal.AsSpan(_list));\nforeach (var vector in spanOfVectors)\n{\naccVector = Vector.Add(accVector, vector);\n}\n\n// Scalar-Product of our vector against the Unit vector is its sum\nvar result = Vector.Dot(accVector, Vector&lt;int&gt;.One);\nreturn result;\n}\n}\n</code></pre> Results: <pre><code>|  Method |       Mean |    Error |   StdDev | Ratio |\n|-------- |-----------:|---------:|---------:|------:|\n| ListSum | 4,493.1 ns | 88.84 ns | 83.10 ns |  1.00 |\n| SumSIMD |   117.7 ns |  0.44 ns |  0.41 ns |  0.03 |\n</code></pre></p>"},{"location":"advanced/SIMD/#getting-minimum-and-maximum-of-a-list","title":"Getting Minimum and Maximum of a list","text":"<p>SIMD can be used to get the smallest and the largest number in a given list.</p> <pre><code>public (int min, int max) GetMinMaxSIMD()\n{\nvar vectors = MemoryMarshal.Cast&lt;int, Vector&lt;int&gt;&gt;(CollectionsMarshal.AsSpan(_numbers));\nvar vMin = new Vector&lt;int&gt;(int.MaxValue);\nvar vMax = new Vector&lt;int&gt;(int.MinValue);\nforeach (var vector in vectors)\n{\nvMin = Vector.Min(vMin, vector);\nvMax = Vector.Max(vMax, vector);\n}\n\nvar min = int.MaxValue;\nvar max = int.MinValue;\n\nfor (var i = 0; i &lt; Vector&lt;int&gt;.Count; i++)\n{\nmin = Math.Min(vMin[i], min);\nmax = Math.Max(vMax[i], min);\n}\n\nreturn (min, max);\n}\n</code></pre> <p>The traditional versionl, could look like this: <pre><code>public (int min, int max) GetMinMax()\n{\nvar min = int.MaxValue;\nvar max = int.MinValue;\n\nfor (var i = 0; i &lt; _numbers.Count; i++)\n{\nmin = Math.Min(_numbers[i], min);\nmax = Math.Max(_numbers[i], min);\n}\n\nreturn (min, max);\n}\n</code></pre></p> <p>Results:</p> <p>The given Llist (<code>_numbers</code>) has 10000 entries.</p> <pre><code>|        Method |      Mean |     Error |    StdDev | Ratio | Rank |\n|-------------- |----------:|----------:|----------:|------:|-----:|\n| GetMinMaxSIMD |  1.544 us | 0.0050 us | 0.0047 us |  0.10 |    1 |\n|     GetMinMax | 15.763 us | 0.0435 us | 0.0407 us |  1.00 |    2 |\n</code></pre>"},{"location":"advanced/arraypool/","title":"ArrayPool","text":"<p>An <code>ArrayPool</code> is a reusable memory pool which tries to decrease garbage collection and memory pressure and therefore enables better performance. Using the array pool normally consists out of three parts:</p> <ul> <li>Renting some array from the <code>ArrayPool</code>.</li> <li>Doing something with the array.</li> <li>Returning the rented array back to the <code>ArrayPool</code>.</li> </ul> <p>As seen by the pattern it is most useful when a lot of smaller arrays are needed in a short time. The major downside of an <code>ArrayPool</code> is that the consumer is now responsible to give back the memory instead of the GC.</p>"},{"location":"advanced/arraypool/#using-the-shared-arraypool","title":"Using the shared ArrayPool","text":"<p><code>ArrayPool&lt;T&gt;.Shared</code> is a predefined array pool that can directly be used.</p> <pre><code>var array = ArrayPool&lt;int&gt;.Shared.Rent(1024);\n// Do something with the array here\nArrayPool&lt;int&gt;.Shared.Return(array);\n</code></pre>"},{"location":"advanced/arraypool/#not-returning-the-rented-array","title":"Not returning the rented array","text":"<p>\u274c Bad Don\u2019t returning the rented array can lead to memory depletion and performance hits as the pool has to be regenerated. The following example uses the <code>ArrayPool</code> in the constructor but does not give it back afterward. <pre><code>public class MyArrayType\n{\nprivate int[] _array;\n\npublic MyArrayType()\n{\n_array = ArrayPool&lt;int&gt;.Shared.Rent(1024);\n}\n}\n</code></pre></p> <p>\u2705 Good Return the array list in <code>Dispose</code> to guarantee the <code>ArrayPool</code> will not be depleted. <pre><code>public class MyArrayType : IDisposable\n{\nprivate int[] _array;\n\npublic MyArrayType()\n{\n_array = ArrayPool&lt;int&gt;.Shared.Rent(1024);\n}\n\npublic void Dispose()\n{\nif (_array != null)\n{\nArrayPool&lt;int&gt;.Shared.Return(_array);\n}\n}\n}\n</code></pre></p>"},{"location":"advanced/arraypool/#assuming-you-get-the-exact-length-you-are-asking-for","title":"Assuming you get the exact length you are asking for","text":"<p>\u274c Bad Assuming that you get the exact amount you asked for. <code>Rent</code> only parameter is called <code>minimumLength</code>. That means you can get a bigger array than you are asking for.</p> <pre><code>var array = ArrayPool&lt;int&gt;.Shared.Rent(1024);\nfor (var i = 0; i &lt; array.Length; i++) // can be more than 1024 iterations\n{\n// ...\n}\n\nArrayPool&lt;int&gt;.Shared.Return(array);\n</code></pre> <p>\u2705 Good Use of a const variable. <pre><code>const int size = 1024;\nvar array = ArrayPool&lt;int&gt;.Shared.Rent(size);\nfor (var i = 0; i &lt; size; i++)\n{\n// ...\n}\n\nArrayPool&lt;int&gt;.Shared.Return(array);\n</code></pre></p>"},{"location":"advanced/arraypool/#assuming-it-is-null-initialized","title":"Assuming it is null initialized","text":"<p>\u274c Bad Renting array from the array is not necessarily zero-initialized. <pre><code>var array = ArrayPool&lt;int&gt;.Shared.Rent(3);\nvar zero = array[0] + array[1] + array[2]; // Is not necessary 0\n</code></pre></p> <p>The following example shows that the program rents an array from the pool and sets some values. Afterward, it returns this memory to the pool. Once more retrieving these values, the program can read its old values. <pre><code>for(var i = 0; i &lt; 4;i++)\n{\nvar array = ArrayPool&lt;int&gt;.Shared.Rent(4);\narray.SetValue(1, i);\nArrayPool&lt;int&gt;.Shared.Return(array);\n}\n\nvar rentedArray = ArrayPool&lt;int&gt;.Shared.Rent(8);\nfor (var i = 0; i &lt; 4; i++)\n{\nConsole.WriteLine(rentedArray[i]);\n}\n</code></pre></p> <p>Output: <pre><code>1\n1\n1\n1\n</code></pre></p>"},{"location":"advanced/arraypool/#performance","title":"Performance","text":"<pre><code>[MemoryDiagnoser]\npublic class Benchmark\n{\nconst int NumberOfItems = 10000;\n\n[Benchmark]\npublic void ArrayViaNew()\n{\nvar array = new int[NumberOfItems];\n}\n[Benchmark]\npublic void SharedArrayPool()\n{\nvar array = ArrayPool&lt;int&gt;.Shared.Rent(NumberOfItems);\nArrayPool&lt;int&gt;.Shared.Return(array);\n}\n}\n</code></pre> <p>Results: <pre><code>|          Method |        Mean |      Error |     StdDev |  Gen 0 | Allocated |\n|---------------- |------------:|-----------:|-----------:|-------:|----------:|\n|     ArrayViaNew | 3,387.04 ns | 263.598 ns | 773.088 ns | 9.5215 |  40,024 B |\n| SharedArrayPool |    40.60 ns |   2.531 ns |   7.462 ns |      - |         - |\n</code></pre></p>"},{"location":"advanced/boxing/","title":"Boxing / Unboxing","text":"<p>This chapter shows (hidden) pitfalls in terms of boxing and unboxing.</p>"},{"location":"advanced/boxing/#enumerate-through-iliststruct-vs-liststruct","title":"Enumerate through <code>IList&lt;struct&gt;</code> vs <code>List&lt;struct&gt;</code>","text":"<p>When you call <code>List&lt;struct&gt;.GetEnumerator()</code> (which will be done in every foreach loop) you get a struct named <code>Enumerator</code>. When calling <code>IList&lt;struct&gt;.GetEnumerator()</code> you get a variable of type <code>IEnumerator&lt;struct&gt;</code>, which contains a boxed version of your value type. In the performance critical section, this can be important.</p> <p>\u274c Bad This will box every individual integer in the list when enumerated through. <pre><code>private int GetSum(IList&lt;int&gt; numbers)\n{\nforeach (var number in numbers)\n// ...\n}\n</code></pre></p> <p>\u2705 Good Using the <code>List&lt;T&gt;</code> implementation avoids the boxing. <pre><code>private int GetSum(List&lt;int&gt; numbers)\n{\nforeach (var number in numbers)\n// ...\n}\n</code></pre></p> <p>\ud83d\udca1 Info: The same applies to <code>Collection&lt;struct&gt;</code> and <code>ICollection&lt;struct&gt;</code>. Basically everytime when you use the interface, changes are that the values get boxed. This also happens with LINQ queries.</p>"},{"location":"advanced/boxing/#benchmark","title":"Benchmark","text":"<pre><code>public class Benchmark\n{\nprivate readonly List&lt;int&gt; numbersList = Enumerable.Range(0, 10_000).ToList();\nprivate readonly IList&lt;int&gt; numbersIList = Enumerable.Range(0, 10_000).ToList();\n\n[Benchmark(Baseline = true)]\npublic int GetSumOfList()\n{\nvar sum = 0;\nforeach (var number in numbersList) { sum += number; }\nreturn sum;\n}\n\n[Benchmark]\npublic int GetSumOfIList()\n{\nvar sum = 0;\nforeach (var number in numbersIList) { sum += number; }\nreturn sum;\n}\n}\n</code></pre> <p>Results: <pre><code>|        Method |      Mean |     Error |    StdDev | Ratio | RatioSD | Allocated | Alloc Ratio |\n|-------------- |----------:|----------:|----------:|------:|--------:|----------:|------------:|\n|  GetSumOfList |  9.392 us | 0.0186 us | 0.0165 us |  1.00 |    0.00 |         - |          NA |\n| GetSumOfIList | 44.098 us | 0.3359 us | 0.3142 us |  4.69 |    0.03 |      40 B |          NA |\n</code></pre></p>"},{"location":"advanced/boxing/#using-liststruct-in-linq-queries-will-box-the-enumerator","title":"Using <code>List&lt;struct&gt;</code> in LINQ queries will box the enumerator","text":"<p>As LINQ queries are built upon <code>IEnumerable&lt;T&gt;</code> passing a list of value types to a LINQ query will box the enumerator. This is especially unwanted in high performance path in your application.</p> <p>\u274c Bad Using LINQ query to get the sum of a <code>List&lt;int&gt;</code>. <pre><code>List&lt;int&gt; numbers = GetNumbers();\n\nvar sum = numbers.Sum(); // This will box the enumerator\n</code></pre></p> <p>\u2705 Good Use foreach with the enumerator of the list to avoid boxing. <pre><code>List&lt;int&gt; numbers = GetNumbers();\n\nvar sum = 0;\nforeach (var number in numbers)\nsum += number;\n</code></pre></p>"},{"location":"advanced/boxing/#benchmark_1","title":"Benchmark","text":"<pre><code>public class Benchmark\n{\nprivate readonly List&lt;int&gt; numbersList = Enumerable.Range(0, 10_000).ToList();\n\n[Benchmark(Baseline = true)]\npublic int GetSumViaForeachList()\n{\nvar sum = 0;\nforeach (var number in numbersList)\nsum += number;\n\nreturn sum;\n}\n\n[Benchmark]\npublic int GetSumViaLINQ() =&gt; numbersList.Sum();\n}\n</code></pre> <p>Results: <pre><code>|               Method |      Mean |     Error |    StdDev | Ratio | RatioSD | Allocated | Alloc Ratio |\n|--------------------- |----------:|----------:|----------:|------:|--------:|----------:|------------:|\n| GetSumViaForeachList |  9.391 us | 0.0210 us | 0.0176 us |  1.00 |    0.00 |         - |          NA |\n|        GetSumViaLINQ | 43.778 us | 0.1257 us | 0.1176 us |  4.66 |    0.02 |      40 B |          NA |\n</code></pre></p>"},{"location":"advanced/iterate_list/","title":"Iterate through a list","text":"<p>The page shows three different ways iterating through a List: <code>for</code>, <code>foreach</code> and via <code>Span&lt;T&gt;</code>.</p> <p>Not all of them are the same in terms of behavior.</p> <p><code>foreach</code> is well known and shows the intend very well. It is slower than a <code>for</code> loop mainly because foreach has to check if the collection gets modified. A <code>for</code> loop can suffer from \u201cone of\u201d issues where you access an index out of bounds. How often does that happen with a <code>foreach</code>? So even though <code>foreach</code> is slower, it is the safest and most verbose option (when you don\u2019t need the index).</p> <p>With <code>CollectionMarshal.AsSpan</code>since .NET 5 we can grab the internal array of List and use it as Span. This is the fastest thanks to a lot of optimizations. Like the <code>for</code> loop there are no checks if the original collection gets modified. You can also use the Span in a <code>foreach</code> struct and still the same holds true. Be aware as the unsafe nature of that function things can get messy. For example the <code>Span&lt;T&gt;</code> can contain stale data, which in the original list is already removed.</p>"},{"location":"advanced/iterate_list/#performance-comparison","title":"Performance comparison","text":"<pre><code>public class Benchmark\n{\n[Params(10, 100, 1000)] public int ArraySize { get; set; }\n\nprivate List&lt;int&gt; numbers;\n\n[GlobalSetup]\npublic void Setup()\n{\nnumbers = Enumerable.Repeat(0, ArraySize).ToList();\n}\n\n[Benchmark(Baseline = true)]\npublic void ForEach() {\nforeach (var num in numbers)\n{\n}\n}\n\n[Benchmark]\npublic void For()\n{\nfor (var i = 0; i &lt; ArraySize; i++)\n{\n_ = numbers[i];\n}\n}\n\n[Benchmark]\npublic void Span()\n{\nvar collectionAsSpan = CollectionsMarshal.AsSpan(numbers);\nfor (var i = 0; i &lt; ArraySize; i++)\n{\n_ = collectionAsSpan[i];\n}\n}\n}\n</code></pre> <p>Results: <pre><code>|  Method | ArraySize |         Mean |      Error |     StdDev | Ratio | RatioSD |\n|-------- |---------- |-------------:|-----------:|-----------:|------:|--------:|\n| ForEach |        10 |    14.558 ns |  0.3226 ns |  0.8328 ns |  1.00 |    0.00 |\n|     For |        10 |     6.053 ns |  0.1391 ns |  0.2166 ns |  0.41 |    0.03 |\n|    Span |        10 |     3.906 ns |  0.0988 ns |  0.0924 ns |  0.27 |    0.01 |\n|         |           |              |            |            |       |         |\n| ForEach |       100 |   161.745 ns |  2.8664 ns |  3.4123 ns |  1.00 |    0.00 |\n|     For |       100 |    67.268 ns |  1.1961 ns |  1.1188 ns |  0.41 |    0.01 |\n|    Span |       100 |    50.935 ns |  1.0039 ns |  1.1158 ns |  0.31 |    0.01 |\n|         |           |              |            |            |       |         |\n| ForEach |      1000 | 1,508.880 ns | 29.7007 ns | 36.4751 ns |  1.00 |    0.00 |\n|     For |      1000 |   636.547 ns | 12.6593 ns | 25.8595 ns |  0.42 |    0.02 |\n|    Span |      1000 |   337.738 ns |  6.7882 ns | 16.6517 ns |  0.22 |    0.01 |\n</code></pre></p>"},{"location":"advanced/iterate_list/#stale-data","title":"Stale data","text":"<p>Be aware that getting the memory slice of a <code>List</code> and modifying the <code>List</code> afterwards will not update the <code>Span</code>.</p> <pre><code>var myList = new List&lt;int&gt; { 1, 2 };\nvar listSlice = CollectionsMarshal.AsSpan(myList);\nmyList.Add(3);\nConsole.Write(listSlice.Length); // This will only print 2\n</code></pre>"},{"location":"advanced/lambda_methodgroup/","title":"Lambda vs method group","text":"<p>This article will show the differences between a lamdbda expression and a method group.</p>"},{"location":"advanced/lambda_methodgroup/#prefer-lambda-expression-over-method-groups","title":"Prefer lambda expression over method groups","text":"<p>Lambda expression can be cached by the .net runtime where as methods groups are not. This can lead to additional allocations if you use .net6 or below (it was improved with .net7).</p> <p>\u274c Bad Use method group. <pre><code>_ints.Where(IsEven);\n</code></pre></p> <p>\u2705 Good Use lambda expression. <pre><code>_ints.Where(i =&gt; IsEven(i));\n</code></pre></p>"},{"location":"advanced/lambda_methodgroup/#benchmark","title":"Benchmark","text":"<pre><code>public class LambdaVsMethodGroup\n{\nprivate IEnumerable&lt;int&gt; _ints = Enumerable.Range(0, 100);\n\n[Benchmark(Baseline = true)]\npublic List&lt;int&gt; MethodGroup() =&gt; _ints.Where(IsEven).ToList();\n\n[Benchmark]\npublic List&lt;int&gt; Lambda() =&gt; _ints.Where(i =&gt; IsEven(i)).ToList();\n\nprivate static bool IsEven(int i) =&gt; i % 2 == 0;\n}\n</code></pre> <p>Results: <pre><code>|      Method |     Mean |    Error |   StdDev | Ratio | RatioSD |\n|------------ |---------:|---------:|---------:|------:|--------:|\n| MethodGroup | 570.4 ns | 10.88 ns | 11.18 ns |  1.00 |    0.00 |\n|      Lambda | 517.6 ns |  6.20 ns |  5.80 ns |  0.91 |    0.02 |\n</code></pre></p>"},{"location":"advanced/lazy/","title":"<code>Lazy&lt;T&gt;</code>","text":"<p>This section will look closer into the <code>Lazy&lt;T&gt;</code> type.</p>"},{"location":"advanced/lazy/#use-the-correct-lazythreadsafetymode-option","title":"Use the correct <code>LazyThreadSafetyMode</code> option","text":"<p>If you are using <code>Lazy</code> only in a single-threaded manner, you can save some resources when providing either the <code>isThreadSafe</code> parameter or pass in the correct <code>LazyThreadSafetyMode</code>. The default is <code>LazyThreadSafetyMode.ExecutionAndPublication</code> which creates locks to ensure the synchronization.</p> <p>\u274c Bad Use the multi-thread safe version in a single-threaded application. <pre><code>var instance = new Lazy&lt;MyClass&gt;(() =&gt; new MyClass());\n</code></pre></p> <p>\u2705 Good Pass the <code>isThreadSafe</code> parameter. <pre><code>var instance = new Lazy&lt;MyClass&gt;(() =&gt; new MyClass(), isThreadSafe: false);\n</code></pre></p> <p>\u2705 Good Pass the correct <code>LazyThreadSafetyMode</code> parameter. <pre><code>var instance = new Lazy&lt;MyClass&gt;(() =&gt; new MyClass(), LazyThreadSafetyMode.None);\n</code></pre></p>"},{"location":"advanced/lazy/#benchmark","title":"Benchmark","text":"<pre><code>public class LazyBenchmark\n{\n[Params(\n        LazyThreadSafetyMode.None,\n        LazyThreadSafetyMode.PublicationOnly,\n        LazyThreadSafetyMode.ExecutionAndPublication)]\npublic LazyThreadSafetyMode Option { get; set; }\n\n[Benchmark]\npublic int Lazy()\n{\nvar lazy = new Lazy&lt;MyClass&gt;(() =&gt; new MyClass(), Option);\nreturn lazy.Value.MyFunc();\n}\n}\n\npublic class MyClass\n{\npublic int MyFunc() =&gt; 2;\n}\n</code></pre> <p>Results: <pre><code>| Method |               Option |     Mean |    Error |   StdDev |\n|------- |--------------------- |---------:|---------:|---------:|\n|   Lazy |                 None | 28.06 ns | 0.641 ns | 1.797 ns |\n|   Lazy |      PublicationOnly | 32.25 ns | 0.676 ns | 1.013 ns |\n|   Lazy | Execu(...)ation [23] | 41.82 ns | 0.829 ns | 1.655 ns |\n</code></pre></p>"},{"location":"advanced/span/","title":"<code>Span&lt;T&gt;</code>","text":"<p>This chapter will look closely to the <code>Span&lt;T&gt;</code> type. The whole idea behind <code>Span&lt;T&gt;</code> is to not allocate additional memory as it operates on the memory slice behind the given data type.</p>"},{"location":"advanced/span/#substring-from-a-string","title":"Substring from a <code>string</code>","text":"<p>Getting a substring of a <code>string</code> via the <code>Substring</code> method will create a new <code>string</code> and therefore a new allocation.</p> <p>\u274c Bad Using <code>Substring</code> to get a part of a string. <pre><code>var text = \"Hello World\";\nvar hello = text.Substring(0, 5);\nvar hello2 = text[..5]; // Range indexer uses Substring under the hood\n</code></pre></p> <p>\u2705 Good Using <code>AsSpan</code> to get the underlying memory. <pre><code>var text = \"Hello World\";\nvar hello = text.AsSpan().Slice(0, 5);\nvar hello2 = text.AsSpan()[..5]; </code></pre></p>"},{"location":"advanced/span/#benchmark","title":"Benchmark","text":"<pre><code>[MemoryDiagnoser]\npublic class SubstringBenchmark\n{\nprivate const string text = \"Hello World\";\n\n[Benchmark(Baseline = true)]\npublic string Substring()\n{\nreturn text[..5];\n}\n\n[Benchmark]\npublic ReadOnlySpan&lt;char&gt; SpanSlice()\n{\nreturn text.AsSpan()[..5];\n}\n}\n</code></pre> <p>Results: <pre><code>|    Method |      Mean |     Error |    StdDev | Ratio |  Gen 0 | Allocated | Alloc Ratio |\n|---------- |----------:|----------:|----------:|------:|-------:|----------:|------------:|\n| Substring | 9.9252 ns | 0.3611 ns | 1.0534 ns |  1.00 | 0.0076 |      32 B |        1.00 |\n| SpanSlice | 0.1921 ns | 0.0428 ns | 0.0653 ns |  0.02 |      - |         - |        0.00 |\n</code></pre></p>"},{"location":"advanced/stackalloc/","title":"stackalloc","text":"<p>The following chapter will show some tips and tricks around the <code>stackalloc</code> and its usage.</p> <p>A <code>stackalloc</code> expression allocates a block of memory on the stack. A stack allocated memory block created during the method execution is automatically discarded when that method returns. Taken from here</p>"},{"location":"advanced/stackalloc/#allocate-only-small-amounts-of-memory","title":"Allocate only small amounts of memory","text":"<p>The stack has a limited size and attempting to allocate a hugerelatively speaking amount of memory and if taken too much a <code>StackOverflowException</code> is thrown which is not recoverable. Linux might have a big stack size but embedded devices can limit the size to the kilobyte range.</p> <p>\u274c Bad Allocate a huge amount. <pre><code>Span&lt;byte&gt; = stackalloc byte[1024 * 1024];\n</code></pre></p> <p>Also be careful if taken user input which can crash the program: <pre><code>Span&lt;byte&gt; = stackalloc byte[userInput];\n</code></pre></p> <p>\u2705 Good Take small amounts of memory. <pre><code>Span&lt;byte&gt; = stackalloc byte[1024];\n</code></pre></p> <p>\u2705 Good Fallback to traditional heap allocation if over a specific threshold. <pre><code>Span&lt;byte&gt; = userInput &lt;= 1024 ? stackalloc byte[1024] : new byte[userInput];\n</code></pre></p>"},{"location":"advanced/stackalloc/#stackalloc-is-not-zero-initialized","title":"<code>stackalloc</code> is not zero initialized","text":"<p>In contrast to arrays allocated via <code>new</code> <code>stackalloc</code> does not zero initialize arrays. Especially if one in the caller chain uses the <code>SkipLocalsInitAttribute</code>.</p> <p>\u274c Bad Don\u2019t relay on zero initialized arrays. <pre><code>Span&lt;int&gt; buffer = stackalloc int[3];\nbuffer[0] = 1;\nbuffer[1] = 1;\n\nint result = buffer[0] + buffer[1] + buffer[2]; // Is not necessarily 2\n</code></pre></p> <p>\u2705 Good  Call <code>Clear</code> or <code>Fill</code> to initialize the array if needed. <pre><code>Span&lt;int&gt; buffer = stackalloc int[3];\nbuffer.Clear(); // or buffer.Fill(0);\nbuffer[0] = 1;\nbuffer[1] = 1;\n\nint result = buffer[0] + buffer[1] + buffer[2]; // Is 2\n</code></pre></p>"},{"location":"advanced/stackalloc/#stackalloc-in-a-loop","title":"<code>stackalloc</code> in a loop","text":"<p>Every <code>stackalloc</code> gets only deallocated after the function terminates. That means in a loop multiple <code>stackalloc</code> will pill up memory which ultimately can lead to an <code>StackOverflowException</code>. Furthermore it is inefficient to allocate always the same amount of memory.</p> <p>\u274c Bad Allocating over and over again the \u201csame\u201d memory inside a loop pilling up stack memory. <pre><code>for (int i = 0; i &lt; 1000; ++i)\n{\nSpan&lt;char&gt; buffer = stackalloc char[256];\n// ...\n}\n</code></pre></p> <p>\u2705 Good Create one slice of memory outside the loop. <pre><code>Span&lt;char&gt; buffer = stackalloc char[256];\nfor (int i = 0; i &lt; 1000; ++i)\n{   // ...\n}\n</code></pre></p>"},{"location":"advanced/struct/","title":"struct","text":"<p><code>struct</code>s can have a positive impact on performance due to their nature of living on the stack instead of the heap. Of course <code>struct</code> will be put onto the heap if they outlive their stack frame.</p>"},{"location":"advanced/struct/#passing-by-value-can-be-faster-than-by-reference","title":"Passing by value can be faster than by reference","text":"<p>If the <code>struct</code> is small enough (at best as wide as a machine word, so 8 bytes on 64bit applications or 4 bytes on 32 bit applications) passing a <code>struct</code> by reference can be significant faster than any reference. The reason is that copying a <code>struct</code> on the stack is a cheap operation when the <code>struct</code> is small enough. A reference in contrast is always as wide as the machine word but on top, for reading values, it has to be dereferences.  </p> <p>\ud83d\udca1 Info: In detail explanation can be found here.</p>"},{"location":"advanced/struct/#allocation-of-small-structs-are-cheaper-than-reference-types","title":"Allocation of small <code>struct</code>s are cheaper than reference types","text":"<p>Heap allocation is more expensive than creating an object on the stack. If used in loops with only local usage of the (small) <code>struct</code> they can improve the performance.</p> <p>\u274c Bad Classes are relatively expensive <pre><code> public void SlimClass()\n{\nvar array = new SlimClass[1000];\nfor (var i = 0; i &lt; 1000; i++)\narray[i] = new SlimClass();\n}\n</code></pre></p> <p>\u2705 Good Structs are cheap to create <pre><code> public void SlimStruct()\n{\nvar array = new SlimStruct[1000];\nfor (var i = 0; i &lt; 1000; i++)\narray[i] = new SlimStruct();\n}\n</code></pre></p> <p>\u26a0\ufe0f Warning If the array of a struct is larger than 85kb it will be moved to the **L**arge **O**bject **H**eap which can give a major performance penalty.</p>"},{"location":"advanced/struct/#benchmark","title":"Benchmark","text":"<pre><code>[GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory), CategoriesColumn]\npublic class RegexBenchmark\n{\n[Params(10, 1_000)]\npublic int ObjectsToCreate { get; set; }\n\n[Benchmark(Baseline = true), BenchmarkCategory(\"Slim\")]\npublic void SlimClass()\n{\nvar array = new SlimClass[ObjectsToCreate];\nfor (var i = 0; i &lt; ObjectsToCreate; i++)\narray[i] = new SlimClass();\n}\n\n[Benchmark, BenchmarkCategory(\"Slim\")]\npublic void SlimStruct()\n{\nvar array = new SlimStruct[ObjectsToCreate];\nfor (var i = 0; i &lt; ObjectsToCreate; i++)\narray[i] = new SlimStruct();\n}\n\n[Benchmark(Baseline = true), BenchmarkCategory(\"Fat\")]\npublic void FatClass()\n{\nvar array = new FatClass[ObjectsToCreate];\nfor (var i = 0; i &lt; ObjectsToCreate; i++)\narray[i] = new FatClass();\n}\n\n[Benchmark, BenchmarkCategory(\"Fat\")]\npublic void FatStruct()\n{\nvar array = new FatStruct[ObjectsToCreate];\nfor (var i = 0; i &lt; ObjectsToCreate; i++)\narray[i] = new FatStruct();\n}\n}\n\npublic class SlimClass { }\npublic struct SlimStruct { }\n\npublic class FatClass\n{\npublic int A, B, C, D, E, F, G, H, I, J, K, L, M, N, Q, R, S, T, U, V, W, X, Y, Z;\n}\n\npublic struct FatStruct\n{\npublic int A, B, C, D, E, F, G, H, I, J, K, L, M, N, Q, R, S, T, U, V, W, X, Y, Z;\n}\n</code></pre> <p>Results: <pre><code>|     Method | Categories | ObjectsToCreate |          Mean |       Error |      StdDev | Ratio | RatioSD |   Gen 0 |   Gen 1 |   Gen 2 | Allocated | Alloc Ratio |\n|----------- |----------- |---------------- |--------------:|------------:|------------:|------:|--------:|--------:|--------:|--------:|----------:|------------:|\n|   FatClass |        Fat |              10 |    248.246 ns |   7.1119 ns |  20.2908 ns |  1.00 |    0.00 |  0.2923 |       - |       - |    1224 B |        1.00 |\n|  FatStruct |        Fat |              10 |     71.918 ns |   2.1169 ns |   6.0054 ns |  0.29 |    0.03 |  0.2352 |       - |       - |     984 B |        0.80 |\n|            |            |                 |               |             |             |       |         |         |         |         |           |             |\n|   FatClass |        Fat |            1000 | 11,551.343 ns | 231.0578 ns | 247.2293 ns |  1.00 |    0.00 | 28.6865 |  0.0305 |       - |  120024 B |        1.00 |\n|  FatStruct |        Fat |            1000 | 54,708.078 ns | 362.9784 ns | 321.7709 ns |  4.73 |    0.12 | 30.2734 | 30.2734 | 30.2734 |   96034 B |        0.80 |\n|            |            |                 |               |             |             |       |         |         |         |         |           |             |\n|  SlimClass |       Slim |              10 |     60.762 ns |   1.1299 ns |   1.6562 ns |  1.00 |    0.00 |  0.0823 |       - |       - |     344 B |        1.00 |\n| SlimStruct |       Slim |              10 |      9.246 ns |   0.1056 ns |   0.0936 ns |  0.15 |    0.01 |  0.0096 |       - |       - |      40 B |        0.12 |\n|            |            |                 |               |             |             |       |         |         |         |         |           |             |\n|  SlimClass |       Slim |            1000 |  5,968.366 ns | 111.5320 ns | 271.4843 ns |  1.00 |    0.00 |  7.6599 |       - |       - |   32024 B |        1.00 |\n| SlimStruct |       Slim |            1000 |    484.738 ns |   8.7875 ns |   8.6305 ns |  0.08 |    0.00 |  0.2441 |       - |       - |    1024 B |        0.03 |\n</code></pre></p>"},{"location":"advanced/struct/#override-equals-and-operator-equals-on-value-types","title":"Override equals and operator equals on value types","text":"<p>When comparing a custom <code>struct</code> with each other dotnet will use reflection to achieve comparison. In performance critical paths this might not be desirable.</p> <p>\u274c Bad Don\u2019t provide overrides for <code>Equals</code> and similar operations. <pre><code>public struct Point\n{\npublic int X { get; set; }\npublic int Y { get; set; }\n}\n\nvar p1 = default(Point);\nvar p2 = default(Point);\nvar isSame = p1 == p2; // Uses reflection to achieve comparison\n</code></pre></p> <p>\u2705 Good Provide explicit implementations. <pre><code>public struct Point : IEquatable&lt;Point&gt; // Implementing the interface is optional\n{\npublic int X { get; set; }\npublic int Y { get; set; }\n\npublic override int GetHashCode() =&gt; ...\npublic override bool Equals(object obj) =&gt; ...\npublic bool Equals(Point p2) =&gt; ...\n\npublic static bool operator ==(Point point1, Point point2) =&gt; point1.Equals(point2);\npublic static bool operator !=(Point point1, Point point2) =&gt; !point1.Equals(point2);\n}\n</code></pre></p> <p>\ud83d\udca1 Info: <code>record struct</code>, which were introduced with C# 10, automatically implement <code>IEquatable</code>. So by using a <code>record struct</code> you get some performance benefits. A more in-depth analysis can be found here.</p>"},{"location":"advanced/struct/#benchmark_1","title":"Benchmark","text":"<pre><code>public class ValueTypeEquals\n{\nprivate readonly PointNoOverride _noOverrideP1 = new();\nprivate readonly PointNoOverride _noOverrideP2 = new();\nprivate readonly PointRecord _pointRecordP1 = new(0, 0);\nprivate readonly PointRecord _pointRecordP2 = new(0, 0);\n\n[Benchmark(Baseline = true)]\npublic bool IsSameNoOverride() =&gt; _noOverrideP1.Equals(_noOverrideP2);\n\n[Benchmark]\npublic bool IsSameOverride() =&gt; _pointRecordP1.Equals(_pointRecordP2);\n}\n\npublic struct PointNoOverride\n{\npublic int X { get; init; }\npublic int Y { get; init; }\n}\n// record struct implements IEquatable&lt;T&gt;\npublic record struct PointRecord(int X, int Y);\n</code></pre> <p>Results: <pre><code>|           Method |       Mean |     Error |    StdDev | Ratio |  Gen 0 | Allocated | Alloc Ratio |\n|----------------- |-----------:|----------:|----------:|------:|-------:|----------:|------------:|\n| IsSameNoOverride | 24.5980 ns | 0.7290 ns | 2.0682 ns |  1.00 | 0.0115 |      48 B |        1.00 |\n|   IsSameOverride |  0.6466 ns | 0.0499 ns | 0.0555 ns |  0.03 |      - |         - |        0.00 |\n</code></pre></p>"},{"location":"advanced/struct/#override-gethashcode-when-used-in-a-dictionary","title":"Override <code>GetHashCode</code> when used in a <code>Dictionary</code>","text":"<p>When a custom defined <code>struct</code> is used as a key in a <code>Dictionary</code> reflection is used to calculate the has of the current object. In performance critical paths that is not desirable.</p> <p>\u274c Bad Rely on the reflection to calculate the hash <pre><code>public struct Point\n{\npublic int X { get; set; }\npublic int Y { get; set; }\n}\n\nvar dictionary = new Dictionary&lt;Point, WorldObject&gt;();\n...\nvar worldObjectAtP1 = dictionary[p1];\n</code></pre></p> <p>\u2705 Good Provide <code>GetHashCode</code> implementation. <pre><code>public struct Point\n{\npublic int X { get; set; }\npublic int Y { get; set; }\n\npublic override int GetHashCode() =&gt; HashCode.Combine(X, Y);\n}\n\nvar dictionary = new Dictionary&lt;Point, WorldObject&gt;();\n...\nvar worldObjectAtP1 = dictionary[p1];\n</code></pre></p> <p>\ud83d\udca1 Info: <code>record struct</code>, which were introduced with C# 10, automatically implement a non reflective <code>GetHashCode</code>. So by using a <code>record struct</code> you get some performance benefits. A more in-depth analysis can be found here.</p>"},{"location":"advanced/struct/#benchmark_2","title":"Benchmark","text":"<pre><code>[MemoryDiagnoser]\npublic class StructGetHashCode\n{\nprivate static readonly PointNoOverride pointNoOverride = new();\nprivate static readonly PointRecord pointOverride = new();\nprivate readonly Dictionary&lt;PointNoOverride, int&gt; dictionaryNoOverride = new()\n{\n{ pointNoOverride, 1 }\n};\nprivate readonly Dictionary&lt;PointRecord, int&gt; dictionaryOverride = new()\n{\n{ pointOverride, 1 }\n};\n\n[Benchmark(Baseline = true)]\npublic int GetFromNoOverride() =&gt; dictionaryNoOverride[pointNoOverride];\n\n[Benchmark]\npublic int GetFromOverride() =&gt; dictionaryOverride[pointOverride];\n}\n\npublic struct PointNoOverride\n{\npublic int X { get; init; }\npublic int Y { get; init; }\n}\n// record struct implements GetHashCode\npublic record struct PointRecord(int X, int Y);\n</code></pre> <p>Results: <pre><code>|            Method |     Mean |    Error |   StdDev |   Median | Ratio | RatioSD |  Gen 0 | Allocated | Alloc Ratio |\n|------------------ |---------:|---------:|---------:|---------:|------:|--------:|-------:|----------:|------------:|\n| GetFromNoOverride | 57.35 ns | 1.303 ns | 3.801 ns | 56.31 ns |  1.00 |    0.00 | 0.0172 |      72 B |        1.00 |\n|   GetFromOverride | 19.45 ns | 0.413 ns | 0.386 ns | 19.30 ns |  0.33 |    0.02 |      - |         - |        0.00 |\n</code></pre></p>"},{"location":"efcore/","title":"EF Core","text":"<p>This section will have more insights around Entity Framework Core related topics.</p>"},{"location":"efcore/asnotracking/","title":"Don't track readonly entities","text":""},{"location":"efcore/asnotracking/#dont-track-readonly-entities","title":"Don\u2019t track readonly entities","text":"<p>When loading models from the database Entity Framework will create proxies of your object for change detection. If you have load objects, which will never get updated this is an unnecessary overhead in terms of performance but also allocations as those proxies have their own memory footprint.</p> <p>\u274c Bad Change detection proxies are created even though it is only meant for reading. <pre><code>return await blogPosts.Where(b =&gt; b.IsPublished)\n.Include(b =&gt; b.Tags)\n.ToListAsync();\n</code></pre></p> <p>\u2705 Good Explicitly say that the entities are not tracked by EF. <pre><code>return await blogPosts.Where(b =&gt; b.IsPublished)\n.Include(b =&gt; b.Tags)\n.AsNoTracking()\n.ToListAsync();\n</code></pre></p>"},{"location":"efcore/asnotracking/#benchmark","title":"Benchmark","text":"<p>A detailed setup and benchmark (which is referred below) can be found on the official https://docs.microsoft.com/en-us/ef/core/performance/efficient-querying#tracking-no-tracking-and-identity-resolution.</p> <pre><code>|       Method | NumBlogs | NumPostsPerBlog |       Mean |    Error |   StdDev |     Median | Ratio | RatioSD |   Gen 0 |   Gen 1 | Gen 2 | Allocated |\n|------------- |--------- |---------------- |-----------:|---------:|---------:|-----------:|------:|--------:|--------:|--------:|------:|----------:|\n|   AsTracking |       10 |              20 | 1,414.7 us | 27.20 us | 45.44 us | 1,405.5 us |  1.00 |    0.00 | 60.5469 | 13.6719 |     - | 380.11 KB |\n| AsNoTracking |       10 |              20 |   993.3 us | 24.04 us | 65.40 us |   966.2 us |  0.71 |    0.05 | 37.1094 |  6.8359 |     - | 232.89 KB |\n</code></pre>"},{"location":"efcore/detailed_logging/","title":"Detailed Logging","text":""},{"location":"efcore/detailed_logging/#enable-detailed-logging-in-debug-builds","title":"Enable Detailed logging in debug builds","text":"<p>You can enable detailed logging in debug builds by adding the <code>EnableDetailedErrors</code> method to the <code>DbContextOptionsBuilder</code> in the <code>ConfigureServices</code> method of the <code>Startup</code> class.</p> <pre><code>services.AddDbContext&lt;AppDbContext&gt;(options =&gt;\n{\noptions.UseSqlServer(connectionString)\n#if DEBUG\n.EnableDetailedErrors()\n#endif\n;\n});\n</code></pre> <p>This can give you vital insights, for example if you misconfigured some mappings/configurations.</p> <p>Warning</p> <p>This is only recommended for development and debugging purposes. It is not recommended to use this in production.</p> <p>You can combine this with the <code>LogTo</code> method to log out the translated queries: <pre><code>services.AddDbContext&lt;AppDbContext&gt;(options =&gt;\n{\noptions.UseSqlServer(connectionString)\n#if DEBUG\n.EnableDetailedErrors()\n.LogTo(Console.WriteLine)\n#endif\n;\n});\n</code></pre></p>"},{"location":"efcore/in_memory_sqlite/","title":"In Memory database with SQLite","text":""},{"location":"efcore/in_memory_sqlite/#in-memory-database-with-sqlite","title":"In-Memory database with SQLite","text":"<p>SQLite can be used as an in-memory database for your code. This brings big advantage in testing. The database is transient, that means as soon as the connection gets closed the memory is freed. One downside is that the in-memory database is not thread-safe by default. This is achieved with the special <code>:memory:</code> data source. The advantage over the In-Memory database package provided via <code>Microsoft.EntityFrameworkCore.InMemory</code> that the SQLite version behaves closer to a real rational database. Also Microsoft disencourages the use of the <code>InMemory</code> provider.</p> <pre><code>var connection = new SqliteConnection(\"DataSource=:memory:\");\nconnection.Open();\n\nservices.AddDbContext&lt;MyDbContext&gt;(options =&gt;\n{\noptions.UseSqlite(connection);\n});\n</code></pre> <p>To make it work with multiple connections at a time, we can utilize the <code>cache=shared</code> identifier for the data source. More information can be found on the official website.</p> <pre><code>var connection = new SqliteConnection(\"DataSource=myshareddb;mode=memory;cache=shared\");\nconnection.Open();\n\nservices.AddDbContext&lt;MyDbContext&gt;(options =&gt;\n{\noptions.UseSqlite(connection);\n});\n</code></pre> <p>The database gets cleaned up when there is no active connection anymore.</p> <p>\ud83d\udca1 Info: You have to install the <code>Microsoft.EntityFrameworkCore.Sqlite</code> package to use the <code>UseSqlite</code> method.</p>"},{"location":"efcore/loadasync/","title":"LoadAsync","text":""},{"location":"efcore/loadasync/#loadasync-split-queries-into-smaller-chunks","title":"<code>LoadAsync</code> - Split queries into smaller chunks","text":"<p><code>LoadAsync</code> in combination with a EF-Core <code>DbContext</code> can load related entities. That is useful when handling with big data sets, cartiasian explosion (wanted or unwanted), lots of joins or unions. Big data sets for the reason, that it can happen that the timeout will be reached easily. As with <code>LoadAsync</code> the query is split up into smaller chunks, those might not hit the timeout individually.</p> <p>This code: <pre><code>return await _context.Books\n.Include(b =&gt; b.BookCategories)\n.ThenInclude(c =&gt; c.Category)\n.Include(c =&gt; x.Author.Biography)\n.ToListAsync();\n</code></pre></p> <p>Will be roughly translated to the following SQL statement: <pre><code>SELECT [b].[Id], [b].[AuthorId], [b].[Title], [a].[Id], [a0].[Id], [t].[BookId], [t].[CategoryId], [t].[Id], [t].[CategoryName], [a].[FirstName], [a].[LastName], [a0].[AuthorId], [a0].[Biography], [a0].[DateOfBirth], [a0].[Nationality], [a0].[PlaceOfBirth]\nFROM [Books] AS [b]\nINNER JOIN [Authors] AS [a] ON [b].[AuthorId] = [a].[Id]\nLEFT JOIN [AuthorBiographies] AS [a0] ON [a].[Id] = [a0].[AuthorId]\nLEFT JOIN (\nSELECT [b0].[BookId], [b0].[CategoryId], [c].[Id], [c].[CategoryName]\nFROM [BookCategories] AS [b0]\nINNER JOIN [Categories] AS [c] ON [b0].[CategoryId] = [c].[Id]\n) AS [t] ON [b].[Id] = [t].[BookId]\nORDER BY [b].[Id], [a].[Id], [a0].[Id], [t].[BookId], [t].[CategoryId]\n</code></pre></p> <p>With <code>LoadAsync</code>: <pre><code>var query = Context.Books;\nawait query.Include(x =&gt; x.BookCategories)\n.ThenInclude(x =&gt; x.Category).LoadAsync();\nawait query.Include(x =&gt; x.Author).LoadAsync();\nawait query.Include(x =&gt; x.Author.Biography).LoadAsync();\nreturn await query.ToListAsync();\n</code></pre></p> <p>Which will be translated into:</p> <pre><code>SELECT [b].[Id], [b].[AuthorId], [b].[Title], [t].[BookId], [t].[CategoryId], [t].[Id], [t].[CategoryName]\nFROM [Books] AS [b]\nLEFT JOIN (\nSELECT [b0].[BookId], [b0].[CategoryId], [c].[Id], [c].[CategoryName]\nFROM [BookCategories] AS [b0]\nINNER JOIN [Categories] AS [c] ON [b0].[CategoryId] = [c].[Id]\n) AS [t] ON [b].[Id] = [t].[BookId]\nORDER BY [b].[Id], [t].[BookId], [t].[CategoryId]\n\n\nSELECT [b].[Id], [b].[AuthorId], [b].[Title], [a].[Id], [a].[FirstName], [a].[LastName]\nFROM [Books] AS [b]\nINNER JOIN [Authors] AS [a] ON [b].[AuthorId] = [a].[Id]\n\nSELECT [b].[Id], [b].[AuthorId], [b].[Title], [a].[Id], [a].[FirstName], [a].[LastName], [a0].[Id], [a0].[AuthorId], [a0].[Biography], [a0].[DateOfBirth], [a0].[Nationality], [a0].[PlaceOfBirth]\nFROM [Books] AS [b]\nINNER JOIN [Authors] AS [a] ON [b].[AuthorId] = [a].[Id]\nLEFT JOIN [AuthorBiographies] AS [a0] ON [a].[Id] = [a0].[AuthorId]\n\nSELECT [b].[Id], [b].[AuthorId], [b].[Title]\nFROM [Books] AS [b]\n</code></pre>"},{"location":"efcore/maxlength_strings/","title":"Define maximum length for strings","text":""},{"location":"efcore/maxlength_strings/#define-maximum-length-for-strings","title":"Define maximum length for strings","text":"<p>When creating a SQL database via code first it is important to tell EF Core how long a string can be otherwise it will always be translated to <code>NVARCHAR(MAX)</code>. This has performance implications as well as other problems like not being able to create an index on that column. Also a rogue application could flood the database.</p> <p>Having this model: <pre><code>public class BlogPost\n{\npublic int Id { get; private set; }\npublic string Title { get; private set; }\npublic string Content { get; private set; }\n}\n</code></pre></p> <p>\u274c Bad Not defining the maximum length of a string will lead to <code>NVARCHAR(max)</code>. <pre><code>public class BlogPostConfiguration : IEntityTypeConfiguration&lt;BlogPost&gt;\n{\npublic void Configure(EntityTypeBuilder&lt;BlogPost&gt; builder)\n{\nbuilder.HasKey(c =&gt; c.Id);\nbuilder.Property(c =&gt; c.Id).ValueGeneratedOnAdd();\n}\n}\n</code></pre></p> <p>Will lead to generation of this SQL table: <pre><code>CREATE TABLE BlogPosts\n(\n[Id] [int] NOT NULL,\n[Title] [NVARCHAR](MAX) NULL,\n[Content] [NVARCHAR](MAX) NULL\n)\n</code></pre></p> <p>\u2705 Good Defining the maximum length will reflect also in the database table. <pre><code>public class BlogPostConfiguration : IEntityTypeConfiguration&lt;BlogPost&gt;\n{\npublic void Configure(EntityTypeBuilder&lt;BlogPost&gt; builder)\n{\nbuilder.HasKey(c =&gt; c.Id);\nbuilder.Property(c =&gt; c.Id).ValueGeneratedOnAdd();\n\n// Set title max length explicitly to 256\nbuilder.Property(c =&gt; c.Title).HasMaxLength(256);\n}\n}\n</code></pre></p> <p>Will lead to generation of this SQL table: <pre><code>CREATE TABLE BlogPosts\n(\n[Id] [int] NOT NULL,\n[Title] [NVARCHAR](256) NULL, -- Now it only can hold 256 characters\n[Content] [NVARCHAR](MAX) NULL\n)\n</code></pre></p>"},{"location":"efcore/retry/","title":"Retry on failure","text":""},{"location":"efcore/retry/#retry-on-failure","title":"Retry on failure","text":"<p>Entity Framework Core supports automatic retry on failure when saving changes to the database. This can be useful when working with a database that is subject to transient failures, such as a database on Azure SQL Database. The examples uses SQL Server but other providers, like PostgreSQL, also support this feature.</p> <pre><code>public void ConfigureServices(IServiceCollection services)\n{\nservices.AddDbContext&lt;MyDbContext&gt;(options =&gt;\noptions.UseSqlServer(\"your_connection_string\",\nsqlServerOptions =&gt;\n{\nsqlServerOptions.EnableRetryOnFailure(\nmaxRetryCount: 3,\nmaxRetryDelay: TimeSpan.FromSeconds(5),\nerrorNumbersToAdd: null);\n}));\n}\n</code></pre>"},{"location":"efcore/splitquery/","title":"SplitQuery","text":""},{"location":"efcore/splitquery/#split-multiple-queries-splitquery","title":"Split multiple queries - <code>SplitQuery</code>","text":"<p>The basic idea is to avoid \u201ccartesian explosion\u201d. A cartesian explosion is when performing a JOIN on the one-to-many relationship then the rows of the one-side are being replicated N times (N = amount of rows on the many side).</p> <p>With SplitQuery instead of having 1 query, you will now have 2 queries where first the \u201cone\u201d side is loaded and in a separate query the \u201cmany\u201d part is loaded. Where the SplitQuery can bring improvement it also has some major drawbacks.</p> <ol> <li>You go two times to your database instead of once.</li> <li>From the database point of view these are two separate queries. So no guarantee of data consistency. There could be race conditions interfering with your result set.</li> </ol> <p>\u274c Bad Every include is resolved by a <code>LEFT JOIN</code> leading to duplicated entries. <pre><code>var blogPosts = await DbContext.Blog\n.Include(b =&gt; b.Posts)\n.Include(b =&gt; b.Tags)\n.ToListAsync();\n</code></pre></p> <p>\u2705 Good Get all related children by a separate query which gets resolved by an <code>INNER JOIN</code>. <pre><code>var blogPosts = await DbContext.Blog\n.Include(b =&gt; b.Posts)\n.Include(b =&gt; b.Tags)\n.AsSplitQuery();\n.ToListAsync();\n</code></pre></p> <p>\ud83d\udca1 Info: There are database which support multiple result sets in one query (for example SQL Server with M ultiple A ctive R esult S et). Here the performance is even better. For more information checkout the official Microsoft page about <code>SplitQuery</code>.</p>"},{"location":"logging/","title":"Logging","text":"<p>This part will have a closer look about tips, tricks and pitfalls in regards to (structured) logging.</p>"},{"location":"logging/compiletime_logging/","title":"Compile-time logging source generator","text":""},{"location":"logging/compiletime_logging/#compie-time-logging-source-generators","title":"Compie-time logging source generators","text":"<p>.NET 6 introduced a new of defining how to log messages with source generators.</p> <pre><code>// The class has to be partial so we can extend the functionality\npublic partial class MyService\n{\nprivate ILogger logger;\n\npublic MyService(ILogger logger) =&gt; this.logger = logger;\n\nprivate void SomeActivity()\n{\nLogSomeActivity(\"Steven\", \"Giesel\");\n}\n\n// The source generator will automatically find the \"logger\" private field and use it\n[LoggerMessage(Message = \"Hello {lastName}, {firstName}\", Level = LogLevel.Information)]\nprivate partial void LogSomeActivity(string firstName, string lastName);\n}\n</code></pre> <p>It is also possible to have a static version, where the user passes in the <code>ILogger</code>. <pre><code>public partial class MyService\n{\nprivate ILogger logger;\n\npublic MyService(ILogger logger) =&gt; this.logger = logger;\n\n\n// The source generator will automatically find the \"logger\" private field and use it\n[LoggerMessage(Message = \"Hello {lastName}, {firstName}\", Level = LogLevel.Information)]\npublic static partial void LogSomeActivity(ILogger logger, string firstName, string lastName);\n}\n</code></pre></p> <p>\ud83d\udca1 Info: A detailed explanation can be found here.</p>"},{"location":"logging/string_interpolation/","title":"Don't use string interpolation","text":""},{"location":"logging/string_interpolation/#dont-use-string-interpolation-when-logging","title":"Don\u2019t use string interpolation when logging","text":"<p>String interpolation normally makes a string more readable but it interferes with structured logging. The reason is that string interpolation gets serialized ahead of time. The underlying logger just sees \u201cone\u201d string instead of its individual components. With that you will loose the ability to search for the format values.</p> <p>\u274c Bad String interpolation when calling logger methods. <pre><code>User user = GetUserFromAPI();\nDateTime when = DateTime.UtcNow;\n\n_logger.LogInformation($\"Creating user: {user} at {when}\");\n</code></pre></p> <p>\u2705 Good Use structured logging to preserve format information. <pre><code>User user = GetUserFromAPI();\nDateTime when = DateTime.UtcNow;\n\n_logger.LogInformation(\"Creating user: {User} at {When}\", user, when);\n</code></pre></p>"},{"location":"nuget/","title":"NuGet","text":"<p>This section will look into tips and tricks when working with NuGet.</p>"},{"location":"nuget/floating_versioning/","title":"Use floating versioning","text":""},{"location":"nuget/floating_versioning/#floating-version","title":"Floating version","text":"<p>NuGet gives the option to use wildcards instead of concrete versions. This gives the ability to use always the latest (major/minor/patch) version of a certain package. </p> <pre><code>&lt;Project Sdk=\"Microsoft.NET.Sdk\"&gt;\n&lt;ItemGroup&gt;\n&lt;PackageReference Include=\"Take.Latest.Minor.Of.Version.3\" Version=\"3.*\" /&gt;\n&lt;PackageReference Include=\"Take.Latest.Patch.Of.Version.3.2\" Version=\"3.2.*\" /&gt;\n&lt;/ItemGroup&gt;\n&lt;/Project&gt;\n</code></pre> <p>This can be especially helpful when working with preview version of dotnet itself. If you always want to have the latest preview version of let\u2019s say the OpenIdConnect-package and Entity Framework core, you could do the following: <pre><code>&lt;ItemGroup&gt;\n&lt;PackageReference Include=\"Microsoft.AspNetCore.Authentication.OpenIdConnect\" Version=\"7.0.0-*\" /&gt;\n&lt;PackageReference Include=\"Microsoft.EntityFrameworkCore\" Version=\"7.0.0-*\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre></p>"},{"location":"regex/","title":"Regular Expressions","text":"<p>This chapter will look more into the usage of regular expressions.</p>"},{"location":"regex/regex_options/","title":"RegExOptions","text":""},{"location":"regex/regex_options/#use-the-correct-regexoption-when-defining-the-regular-expression","title":"Use the correct <code>RegexOption</code> when defining the regular expression.","text":"<p>When defining a regular expression, one can define <code>RegexOption</code>s, which enable fine-grained control over the regular expression engine. That also works with the newly introduced <code>RegexGenerator</code> introduced in .net 7, as they use the same attributes.</p>"},{"location":"regex/regex_options/#compiled","title":"<code>Compiled</code>","text":"<p>This flags (which is the default for <code>RegexGenerator</code> in .net7, so you do not have to provide that argument for them) enables the compilation of the regular expression into the MSIL code of the application. That brings performance improvements in trade-off in expense of a bigger startup time of your application. There are only small scenarios, where this flag does not make sense.</p>"},{"location":"regex/regex_options/#explicitcapture","title":"<code>ExplicitCapture</code>","text":"<p>If you don\u2019t work with capture groups, you can safely provide this flag as this tells the regex engine not to look for implicit captures. Explicit captures are something like this: <code>?&lt;groupname&gt;</code>.</p>"},{"location":"regex/regex_options/#defining-multiple-values","title":"Defining multiple values","text":"<p>As <code>RegexOption</code> are defined as flags, you can provide multiple arguments delimited by the <code>|</code> characters (bitwise or).</p> <pre><code>public class RegexBenchmark\n{\nprivate const string Sentence = \"Hello this is an example of stock tips!\";\nprivate const string RegexString = @\"(\\W|^)stock\\stips(\\W|$)\";\nprivate static readonly Regex StockTips = new(RegexString);\nprivate static readonly Regex StockTipsCompiled = new(RegexString, RegexOptions.Compiled);\nprivate static readonly Regex StockTipsExplicitCapture = new(RegexString, RegexOptions.ExplicitCapture);\nprivate static readonly Regex StockTipsAllCombined = new(RegexString,\nRegexOptions.Compiled | RegexOptions.ExplicitCapture);\n\n[Benchmark(Baseline = true)]\npublic bool HasMatch() =&gt; StockTips.IsMatch(Sentence);\n\n[Benchmark]\npublic bool HasMatchCompiled() =&gt; StockTipsCompiled.IsMatch(Sentence);\n\n[Benchmark]\npublic bool HasMatchExplicitCapture() =&gt; StockTipsExplicitCapture.IsMatch(Sentence);\n\n[Benchmark]\npublic bool HasMatchCombined() =&gt; StockTipsAllCombined.IsMatch(Sentence);\n}\n</code></pre> <p>Results: <pre><code>|                  Method |       Mean |    Error |   StdDev | Ratio |\n|------------------------ |-----------:|---------:|---------:|------:|\n|                HasMatch | 1,348.4 ns | 17.48 ns | 16.35 ns |  1.00 |\n|        HasMatchCompiled |   650.0 ns |  3.59 ns |  3.36 ns |  0.48 |\n| HasMatchExplicitCapture | 1,062.4 ns |  5.50 ns |  5.14 ns |  0.79 |\n|        HasMatchCombined |   528.0 ns |  3.09 ns |  2.89 ns |  0.39 |\n</code></pre></p>"},{"location":"regex/right_to_left/","title":"Right to left search","text":""},{"location":"regex/right_to_left/#right-to-left-search","title":"Right to left search","text":"<p>The <code>RegexOption.RightToLeft</code> allows the regex engine to search from the end to the start. That can bring major gains if you expect the match at the end of the string rather than the beginning.</p> <pre><code>public class RegexBenchmark\n{\nprivate const string Sentence = \"Hello this is an example of stock tips!\";\nprivate const string RegexString = @\"(\\W|^)stock\\stips(\\W|$)\";\nprivate static readonly Regex StockTips = new(RegexString, RegexOptions.Compiled);\nprivate static readonly Regex StockTipsRightToLeft = new(RegexString,\nRegexOptions.Compiled | RegexOptions.RightToLeft);\n\n[Benchmark(Baseline = true)]\npublic bool HasMatch() =&gt; StockTips.IsMatch(Sentence);\n\n[Benchmark]\npublic bool HasMatchRightToLeft() =&gt; StockTipsRightToLeft.IsMatch(Sentence);\n}\n</code></pre> <p>Results: <pre><code>|              Method |      Mean |    Error |   StdDev | Ratio |\n|-------------------- |----------:|---------:|---------:|------:|\n|            HasMatch | 649.54 ns | 1.923 ns | 1.799 ns |  1.00 |\n| HasMatchRightToLeft |  48.23 ns | 0.153 ns | 0.143 ns |  0.07 |\n</code></pre></p>"},{"location":"regex/source_generator/","title":"Source Code Generators","text":"<p>This page will look at how source code generators can impact regular expressions.</p>"},{"location":"regex/source_generator/#source-code-generators-and-regular-expressions","title":"Source Code Generators and Regular Expressions","text":"<p>Since .NET 7 we have the possibility to use source code generators for regular expressions. The advantage over the regular approach is that we can get the same performance as <code>new Regex(\"...\", RegexOptions.Compiled)</code> and the startup benefit of <code>Regex.CompileToAssembly</code>, but without the complexity of <code>CompileToAssembly</code>. As the code is generated it can be viewed and debugged.</p> <p>So instead of this code: <pre><code>private static readonly Regex HelloOrWorldCompiled =\nnew(\"Hello|World\", RegexOptions.Compiled | RegexOptions.IgnoreCase | RegexOptions.CultureInvariant);\n</code></pre></p> <p>We can write it like this: <pre><code>[GeneratedRegex(\"Hello|World\", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant)]\nprivate static partial Regex HelloOrWorldGenerator();\n</code></pre></p>"}]}